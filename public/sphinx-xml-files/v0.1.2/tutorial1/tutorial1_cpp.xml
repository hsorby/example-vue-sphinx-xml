<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="/Users/hsor001/Projects/Webstorm/test-sphinx/docs/tutorials/tutorial1/tutorial1_cpp.rst">
    <target refid="tutorial1-cpp"></target>
    <section ids="tutorial-1-c-reading-and-writing-cellml-files tutorial1-cpp" names="tutorial\ 1\ c++:\ reading\ and\ writing\ cellml\ files tutorial1_cpp">
        <title>Tutorial 1 C++: Reading and writing CellML files</title>
        <paragraph>For overview, please see the <reference internal="True" refuri="outline1#tutorial1"><inline classes="std std-ref">Tutorial 1 overview page</inline></reference>.
            For instructions in Python please see the <reference internal="True" refuri="tutorial1_py#tutorial1-py"><inline classes="std std-ref">Tutorial 1 in Python</inline></reference> page instead.</paragraph>
        <paragraph><strong>Requirements</strong></paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><download_reference filename="f569ae31e378f9944d5d3a27fd8d2cbe/CMakeLists.txt" refdoc="tutorials/tutorial1/tutorial1_cpp" refdomain="" refexplicit="False" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file for building this tutorial;</paragraph>
            </list_item>
            <list_item>
                <paragraph><download_reference filename="b85f96ac1f7dbff74f0f3dc1273c0ea8/tutorial1.cpp" refdoc="tutorials/tutorial1/tutorial1_cpp" refdomain="" refexplicit="False" reftarget="tutorial1.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial1.cpp</literal></download_reference> Either the skeleton code, or ..</paragraph>
            </list_item>
            <list_item>
                <paragraph><download_reference filename="27c7aee0282cf5e923e4d6fe57d371f8/tutorial1_complete.cpp" refdoc="tutorials/tutorial1/tutorial1_cpp" refdomain="" refexplicit="False" reftarget="tutorial1_complete.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial1_complete.cpp</literal></download_reference> the completed tutorial code; and</paragraph>
            </list_item>
            <list_item>
                <paragraph><download_reference filename="76f2da26e9f13f2f1c9b5ecda4b061f3/tutorial1.cellml" refdoc="tutorials/tutorial1/tutorial1_cpp" refdomain="" refexplicit="False" reftarget="../resources/tutorial1.cellml" reftype="download" refwarn="False"><literal classes="xref download">../resources/tutorial1.cellml</literal></download_reference> The input CellML file to read.</paragraph>
            </list_item>
        </bullet_list>
        <topic classes="contents local" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="setup">0: Setup</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="deserialising-a-cellml-file">1: Deserialising a CellML file</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id3" refid="investigate-the-contents-of-the-model">2: Investigate the contents of the model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="serialise-the-model-and-output">3: Serialise the model and output</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="setup" names="0:\ setup">
            <title refid="id1">0: Setup</title>
            <paragraph>For each of the tutorials, there is template code provided for you to get started in each of the tutorial folders.</paragraph>
            <container classes="dothis">
                <paragraph><strong>0.a</strong> Navigate into the “tutorial1” folder and confirm that you’re able to compile and run this template against the libCellML library.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">cmake -DINSTALL_PREFIX=../../install .
make -j</literal_block>
            <paragraph>Running the template:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">./tutorial1</literal_block>
            <paragraph>… should give the output:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">-----------------------------------------------
TUTORIAL 1: READING AND WRITING CELLML FILES
-----------------------------------------------</literal_block>
        </section>
        <section ids="deserialising-a-cellml-file" names="1:\ deserialising\ a\ cellml\ file">
            <title refid="id2">1: Deserialising a CellML file</title>
            <paragraph>CellML is a format in which all the information is stored in a strict hierarchical way.
                In order for this information to be transformed into a format which can be <emphasis>used</emphasis> for modelling and simulation it needs to be
                <emphasis>deserialised</emphasis> into the internal <literal classes="code">Model</literal> format.
                The hard work of this transformation is done by the <literal classes="code">Parser</literal> object which will take a raw CellML string which represents a model and return its corresponding <literal classes="code">Model</literal> item.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> Open the file and read its contents.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">std::ifstream inFile("tutorial1.cellml");
std::stringstream inFileContents;
inFileContents &lt;&lt; inFile.rdbuf();</literal_block>
            <paragraph>At this stage our <literal classes="code">inFileContents</literal> contains the raw CellML from the input file provided, <literal classes="code">tutorial1.cellml</literal>.
                You can either copy the <literal classes="code">tutorial1.cellml</literal> file to this folder, or use a relative file path to access it.</paragraph>
            <container classes="nb">
                <paragraph>All the files for each tutorial are provided for you in the <literal classes="code">resources</literal> folder: though they are designed to build from one to the next, you’re able to use the ready-made ones if you want to jump in at any point.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> Now we need to transform the raw CellML import into the linked <literal classes="code">Model</literal> using the <literal classes="code">Parser</literal>.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Create a parser instance
auto parser = libcellml::Parser::create();

// Create a ModelPtr instance and populate it with the string contents
// from the inFileContents item:
auto myFirstModel = parser-&gt;parseModel(inFileContents.str());</literal_block>
            <paragraph>Now we have a <emphasis>deserialsied</emphasis> CellML model which we can manipulate using the libCellML library.</paragraph>
        </section>
        <section ids="investigate-the-contents-of-the-model" names="2:\ investigate\ the\ contents\ of\ the\ model">
            <title refid="id3">2: Investigate the contents of the model</title>
            <paragraph>Now that we have a model, let’s see what’s inside it.
                All retrieval functions - where you want to read something about any item - are callable from simple functions naming the thing you want.
                For example, to find the name of the model we simply call its <literal classes="code">name()</literal> function:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">std::string modelName = myFirstModel-&gt;name();
auto modelId = myFirstModel-&gt;id();</literal_block>
            <paragraph>Obviously, the type of item you’re retrieving will determine how you declare it.
                Note that names and ids are both returned as strings, but you could use the <literal classes="code">auto</literal> type (as above) too.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Find out the name and id of your model and print it to the terminal.</paragraph>
            </container>
            <paragraph>The <literal classes="code">Model</literal> itself stores two kinds of objects: a set of <literal classes="code">Units</literal> objects, and a set of <literal classes="code">Component</literal> objects.  There are generic <literal classes="code">somethingCount()</literal> functions which will return the number of <literal classes="code">Something</literal> items within that object:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">int numberOfComponents = model-&gt;componentCount();</literal_block>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Find out the number of <literal classes="code">Component</literal> items in the model, and print it to the terminal.</paragraph>
            </container>
            <paragraph>Items like components and units (and later, variables) which are stored in sets can be accessed by their index as well as by their name.
                At this stage, we don’t <emphasis>know</emphasis> the name of the components, so we’ll have to use their indices to access them for printing to the terminal.
                The indices start at <literal classes="code">0</literal>.</paragraph>
            <paragraph>Each <literal classes="code">Component</literal> itself (or later, <literal classes="code">Units</literal> or <literal classes="code">Variable</literal>) is retrieved from its parent item as a pointer (that is, a <literal classes="code">ComponentPtr</literal> type) using the same idiom as the names and ids:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Retrieve the 33rd component from myFirstModel.  Note the indexing from zero.
auto thirtyThirdComponent = myFirstModel-&gt;component(32);</literal_block>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Retrieve the first component from the model, and print its name and id to the terminal.</paragraph>
            </container>
            <paragraph><literal classes="code">Component</literal> items in turn contain four kinds of items, these being:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>a set of <literal classes="code">Variable</literal> items;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>a <literal classes="code">MathML</literal> string which controls the governing mathematical equations
                        of the model behaviour;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>(for later) a set of <literal classes="code">Reset</literal> items; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>(also for later) an optional nested subset of <literal classes="code">Component</literal> items too.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>In this tutorial we’ll only look at the variables and maths, leaving the nested components for <reference internal="True" refuri="../tutorial6/outline6#tutorial6"><inline classes="std std-ref">Tutorial 6</inline></reference>.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.d</strong> Retrieve the number of variables inside your component, and print it to the screen.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.e</strong> Create a loop through the variables, and print the names of each to the screen.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.f</strong> We will look more at what the MathML string actually <emphasis>means</emphasis> in later tutorials, but for now, retrieve the MathML string from your component using the <literal classes="code">math()</literal> function, and print it to the screen.</paragraph>
            </container>
        </section>
        <section ids="serialise-the-model-and-output" names="3:\ serialise\ the\ model\ and\ output">
            <title refid="id4">3: Serialise the model and output</title>
            <paragraph>Now that you’ve seen how to <emphasis>deserialise</emphasis> a CellML file into a model using the <literal classes="code">Parser</literal>, it’s time to go in the other direction.
                This reverse operation is handled by the <literal classes="code">Printer</literal>, which will transform a model into a string for file output.</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">auto printer = libcellml::Printer::create();
std::string serialisedModelString = printer-&gt;printModel(myFirstModel);</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Create a printer and use it to deserialise your model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> Write that serialised string to a new <literal classes="code">.cellml</literal> file.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Go and have a cuppa, you’re done :)</paragraph>
            </container>
        </section>
    </section>
</document>
