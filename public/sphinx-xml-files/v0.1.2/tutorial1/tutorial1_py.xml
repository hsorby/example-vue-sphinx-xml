<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="/Users/hsor001/Projects/Webstorm/test-sphinx/docs/tutorials/tutorial1/tutorial1_py.rst">
    <target refid="tutorial1-py"></target>
    <section ids="tutorial-1-python-reading-and-writing-cellml-files tutorial1-py" names="tutorial\ 1\ python:\ reading\ and\ writing\ cellml\ files tutorial1_py">
        <title>Tutorial 1 Python: Reading and writing CellML files</title>
        <paragraph>For overview, please see the <reference internal="True" refuri="outline1#tutorial1"><inline classes="std std-ref">Tutorial 1 overview page</inline></reference>.
            These are the Python instructions.
            For C++ please see the <reference internal="True" refuri="tutorial1_cpp#tutorial1-cpp"><inline classes="std std-ref">Tutorial 1 C++</inline></reference> page instead.</paragraph>
        <paragraph><strong>Requirements</strong></paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><download_reference filename="09bc82cea89b7f0b74c0249ad730717c/tutorial1.py" refdoc="tutorials/tutorial1/tutorial1_py" refdomain="" refexplicit="False" reftarget="tutorial1.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial1.py</literal></download_reference> Either the skeleton code; or …</paragraph>
            </list_item>
            <list_item>
                <paragraph><download_reference filename="a85763f4c4cbde6a1889b75c1ac65f6b/tutorial1_complete.py" refdoc="tutorials/tutorial1/tutorial1_py" refdomain="" refexplicit="False" reftarget="tutorial1_complete.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial1_complete.py</literal></download_reference> the completed tutorial code; and</paragraph>
            </list_item>
            <list_item>
                <paragraph><download_reference filename="76f2da26e9f13f2f1c9b5ecda4b061f3/tutorial1.cellml" refdoc="tutorials/tutorial1/tutorial1_py" refdomain="" refexplicit="False" reftarget="../resources/tutorial1.cellml" reftype="download" refwarn="False"><literal classes="xref download">../resources/tutorial1.cellml</literal></download_reference> The input CellML file to read.</paragraph>
            </list_item>
        </bullet_list>
        <topic classes="contents local" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="setup">0: Setup</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="deserialising-a-cellml-file">1: Deserialising a CellML file</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id3" refid="investigate-the-contents-of-the-model">2: Investigate the contents of the model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="serialise-the-model-and-output">3: Serialise the model and output</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="setup" names="0:\ setup">
            <title refid="id1">0: Setup</title>
            <paragraph>For each of the tutorials, there is template code provided for you to get started in each of the <literal classes="code">tutorial*.py</literal> files.</paragraph>
            <container classes="dothis">
                <paragraph><strong>0.a</strong> Confirm that you’re able to run the <literal classes="code">tutorial1.py</literal> template against the libCellML library.
                    Navigate into the <literal classes="code">tutorial1</literal> directory and run the skeleton code file, <literal classes="code">tutorial1.py</literal>.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">cd tutorial1
python tutorial1.py</literal_block>
            <paragraph>This should give the output:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">-----------------------------------------------------
    TUTORIAL 1: READING AND WRITING CellML2 FILES
-----------------------------------------------------</literal_block>
        </section>
        <section ids="deserialising-a-cellml-file" names="1:\ deserialising\ a\ cellml\ file">
            <title refid="id2">1: Deserialising a CellML file</title>
            <paragraph>CellML is a format in which all the information is stored in a strictly hierarchical  - or <emphasis>serialised</emphasis> - way.
                In order for this information to be transformed into a format which can be used for modelling and simulation it needs to be
                <emphasis>de-serialised</emphasis> into the internal <literal classes="code">Model</literal> format.
                The hard work of this transformation is done by a <literal classes="code">Parser</literal> object which will take a raw CellML string which represents a serialised model and return its corresponding de-serialised <literal classes="code">Model</literal> item.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> Open the file and read its contents.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">#  1.a   Open the tutorial1.cellml file for reading.
read_file = open("../resources/tutorial1.cellml", "r")
read_file_contents = read_file.read()</literal_block>
            <paragraph>At this stage our <literal classes="code">read_file_contents</literal> contains the raw CellML from the input file provided, <literal classes="code">tutorial1.cellml</literal>.</paragraph>
            <paragraph><strong>Note</strong> that all the files for each tutorial are provided for you in the <literal classes="code">resources</literal> folder: though they are designed to build from one to the next, you’re able to use the ready-made ones if you want to jump in at any point.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> Now we need to transform the raw CellML import into the linked <literal classes="code">Model</literal> using the <literal classes="code">Parser</literal>.
                    This is quite straightforward:</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">#  1.b   Create a libCellML Parser, and use it to parse the file
#        string contents and convert it into a CellML Model structure.
parser = libcellml.Parser()
model = parser-&gt;parseModel(read_file_contents)</literal_block>
            <paragraph>Now we have a <emphasis>deserialsied</emphasis> CellML model which we can manipulate using the libCellML library.</paragraph>
        </section>
        <section ids="investigate-the-contents-of-the-model" names="2:\ investigate\ the\ contents\ of\ the\ model">
            <title refid="id3">2: Investigate the contents of the model</title>
            <paragraph>Now that we have a model, let’s see what’s inside it.
                All retrieval functions - where you want to read something about any item - are callable from simple functions naming the thing you want.
                For example, to find the name of the model we simply call its <literal classes="code">name()</literal> function:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">my_model_name = my_first_model.name()
my_model_id = my_first_model.id()</literal_block>
            <paragraph>Obviously, the type of item you’re retrieving will determine how you declare it: names and ids are returned as strings.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Find out the name and id of your model and print it to the
                    terminal.</paragraph>
            </container>
            <paragraph>The <literal classes="code">Model</literal> itself stores two kinds of objects: a set of <literal classes="code">Units</literal> objects, and a set of <literal classes="code">Component</literal> objects.  There are generic <literal classes="code">somethingCount</literal> functions which will return the number of <literal classes="code">Something</literal> items within that object:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">number_of_components = model.componentCount()</literal_block>
            <container classes="dothis">
                <paragraph><strong>2.b</strong>
                    Find out the number of <literal classes="code">Component</literal> items in the model, and print it to the terminal.</paragraph>
            </container>
            <paragraph>Items like components and units (and later, variables) which are stored in sets can be accessed by their index as well as by their name.
                At this stage, we don’t <emphasis>know</emphasis> the name of the components, so we’ll have to use their index to access them for printing to the terminal.
                The indices begin from <literal classes="code">0</literal>.</paragraph>
            <paragraph>Each <literal classes="code">Component</literal> itself (or later, <literal classes="code">Units</literal> or <literal classes="code">Variable</literal>) is retrieved from its parent item using the same idiom as the names and ids:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Retrieve the 33rd component from my_first_model.  Note the indexing from zero.
component_33 = my_first_model.component(32)</literal_block>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Retrieve the first component from the model, and print its name and id to the terminal.</paragraph>
            </container>
            <paragraph><literal classes="code">Component</literal> items in turn contain four kinds of items, these being:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>a set of <literal classes="code">Variable</literal> items;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>a <literal classes="code">MathML</literal> string which controls the governing mathematical equations of the model behaviour;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>(for later) a set of <literal classes="code">Reset</literal> items; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>(also for later) an optional nested subset of <literal classes="code">Component</literal> items too.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>In this tutorial we’ll only look at the variables and maths, leaving the nested components for <reference internal="True" refuri="../tutorial6/tutorial6_py#tutorial6-py"><inline classes="std std-ref">Tutorial 5</inline></reference>.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.d</strong> Retrieve the number of variables inside the component, and print it to the screen.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.e</strong> Create a loop through the variables, retrieve the names of each, and them to the screen.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.f</strong> We will look more at what the MathML string actually <emphasis>means</emphasis> in later tutorials, but for now, retrieve the MathML string from your component using the <literal classes="code">math()</literal> function, and print it to the screen.</paragraph>
            </container>
        </section>
        <section ids="serialise-the-model-and-output" names="3:\ serialise\ the\ model\ and\ output">
            <title refid="id4">3: Serialise the model and output</title>
            <paragraph>Now that you’ve seen how to <emphasis>deserialise</emphasis> a CellML file into a model using the <literal classes="code">Parser</literal>, it’s time to go in the other direction.
                This reverse operation is handled by the <literal classes="code">Printer</literal>, which will transform a model into a string for file output.</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Create a printer instance.
printer = libcellml.Printer()

# Use the printer to serialse a model into a string.
serialised_model_string = printer-&gt;printModel(my_first_model)</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Create a printer and use it to deserialise your model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> Write that serialised string to a new <literal classes="code">.cellml</literal> file.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Go and have a cuppa, you’re done :)</paragraph>
            </container>
        </section>
    </section>
</document>
