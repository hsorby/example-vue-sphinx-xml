<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="/Users/hsor001/Projects/Webstorm/test-sphinx/docs/tutorials/tutorial4/tutorial4_py.rst">
    <target refid="tutorial4-py"></target>
    <section ids="tutorial-4-python-generating-code-and-model-simulation tutorial4-py" names="tutorial\ 4\ python:\ generating\ code\ and\ model\ simulation tutorial4_py">
        <title>Tutorial 4 Python: Generating code and model simulation</title>
        <paragraph>This tutorial assumes that you are comfortable with:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>Interacting with a model and its entities using the API (see <reference internal="True" refuri="../tutorial3/tutorial3_py#tutorial3-py"><inline classes="std std-ref">Tutorial 3</inline></reference>); and</paragraph>
            </list_item>
            <list_item>
                <paragraph>Using the Generator functionality to output files in C or Python (see <reference internal="True" refuri="../tutorial3/tutorial3_py#tutorial3-py"><inline classes="std std-ref">Tutorial 3</inline></reference>).</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>By the end of this tutorial you will be able to:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>Interact with files created by the <literal classes="code">Generator</literal> to retrieve information for integrating; and</paragraph>
            </list_item>
            <list_item>
                <paragraph>Use the simple solver provided to numerically integrate the governing equations of the model.</paragraph>
            </list_item>
        </bullet_list>
        <topic classes="contents local" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="include-the-generated-code-in-this-project">1: Include the generated code in this project</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="investigate-the-information-items-in-the-generated-files">2: Investigate the information items in the generated files</reference></paragraph>
                    <bullet_list>
                        <list_item>
                            <paragraph><reference ids="id3" refid="classification-of-variables">Classification of variables</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="investigate-the-functions-provided-in-the-generated-files">3: Investigate the functions provided in the generated files</reference></paragraph>
                    <bullet_list>
                        <list_item>
                            <paragraph><reference ids="id5" refid="allocating-arrays">Allocating arrays</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id6" refid="defining-the-initial-values">Defining the initial values</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id7" refid="iterate-through-the-solution">4: Iterate through the solution</reference></paragraph>
                    <bullet_list>
                        <list_item>
                            <paragraph><reference ids="id8" refid="specification-of-the-variables">Specification of the variables</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id9" refid="specification-of-states-and-rates">Specification of states and rates</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id10" refid="output">5: Output</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="include-the-generated-code-in-this-project" names="1:\ include\ the\ generated\ code\ in\ this\ project">
            <title refid="id1">1: Include the generated code in this project</title>
            <paragraph>In <reference internal="True" refuri="../tutorial3/outline3#tutorial3"><inline classes="std std-ref">Tutorial 3</inline></reference> you created a CellML model representing the population dynamics in a predator-prey situation, and used the <literal classes="code">Generator</literal> to write files which can be run using a numerical integration solver in either Python or C.</paragraph>
            <paragraph>This tutorial is slightly different from the other ones because you will need to change the way your project is linked in order to include the generated code.
                As always, if you didn’t complete the earlier tutorial in which the generated code was created, you can use files from the
                <literal classes="code">resources</literal> folder instead.</paragraph>
            <paragraph>Because this is for generated code in Python we will need the file:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="46dadf8bfa07acb6c7f9014e1e260c44/tutorial3_PredatorPrey_generated.py" refdoc="tutorials/tutorial4/tutorial4_py" refdomain="" refexplicit="False" reftarget="../resources/tutorial3_PredatorPrey_generated.py" reftype="download" refwarn="False"><literal classes="xref download">../resources/tutorial3_PredatorPrey_generated.py</literal></download_reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The generated code exists in its own module which can be imported directly into your script for manipulation.
                It’s best to do this in a general manner, so using the Python <literal classes="code">import some_thing as some_alias</literal> idiom you can then
                use <literal classes="code">some_alias</literal> throughout the rest of the code.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.a</strong>  Import the file generated in Tutorial 3 using the aliasing idiom as above.
                    Note that this will need to be in the same directory as your script, or a child: you cannot reference it from its current location in the <literal classes="code">resources</literal> directory; you’ll need to move or copy it here.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> The version which the generated code was created with is stored in the module in a variable called <literal classes="code">some_alias.LIBCELLML_VERSION</literal>.
                    Print this to the terminal and check that it matches the version of libCellML library which you’re using, just like in
                    <reference internal="True" refuri="../tutorial0/outline0#tutorial0"><inline classes="std std-ref">Tutorial 0</inline></reference>.</paragraph>
            </container>
        </section>
        <section ids="investigate-the-information-items-in-the-generated-files" names="2:\ investigate\ the\ information\ items\ in\ the\ generated\ files">
            <title refid="id2">2: Investigate the information items in the generated files</title>
            <paragraph>This step is about figuring out what’s contained in the generated file, and demonstrating how you can use it to run your simulation.</paragraph>
            <paragraph>The implementation code contains some constants as well as functions which make it simple to switch between models for solution.
                This tutorial will pretend that you know nothing about the contents of the CellML model for which the file was generated, and take you through connecting it to a general numerical integrator.</paragraph>
            <section ids="classification-of-variables" names="classification\ of\ variables">
                <title refid="id3">Classification of variables</title>
                <paragraph>The <literal classes="code">Generator</literal> then classifies all the <literal classes="code">Variable</literal> items within each <literal classes="code">Component</literal> as:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><emphasis>variables</emphasis> do not require integration, but come in three types:</paragraph>
                            <bullet_list bullet="-">
                                <list_item>
                                    <paragraph><literal classes="code">CONSTANT</literal> variables do not need any kind of calculation;</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><literal classes="code">COMPUTED_CONSTANT</literal> variables need calculation but not integration; and</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><literal classes="code">ALGEBRAIC</literal> variables need …?? <strong>TODO</strong></paragraph>
                                </list_item>
                            </bullet_list>
                        </list_item>
                        <list_item>
                            <paragraph><emphasis>VOI</emphasis> variables are the base “variables of integration”, specified by the <literal classes="code">&lt;bvar&gt;</literal>
                                tags in the MathML.  These must not be initialised.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><emphasis>states</emphasis> are those variables which do need integration by a solver.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <paragraph>We can see the results of this classification process in the generated code:</paragraph>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Inside the generated "tutorial3_PredatorPrey_generated.py" file:

# Define the VOI variable of integration, its units and the name of its parent component.
VOI_INFO = {"name": "time", "units": "day", "component": "predator_prey_component"}

# Define the states: the variables which require integration.
STATE_INFO = [
  {"name": "y_s", "units": "number_of_sharks", "component": "predator_prey_component"},
  {"name": "y_f", "units": "thousands_of_fish", "component": "predator_prey_component"}
]

# Define the CONSTANT and COMPUTED_CONSTANT variables: these do not require integration.
VARIABLE_INFO = [
    {"name": "a", "units": "per_day", "component": "predator_prey_component", "type": VariableType.CONSTANT},
    {"name": "b", "units": "per_shark_day", "component": "predator_prey_component", "type": VariableType.CONSTANT},
    {"name": "d", "units": "per_1000fish_day", "component": "predator_prey_component", "type": VariableType.CONSTANT},
    {"name": "c", "units": "per_day", "component": "predator_prey_component", "type": VariableType.COMPUTED_CONSTANT}
]</literal_block>
                <paragraph>These are accessible in the imported module:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal classes="code">VARIABLE_COUNT</literal> is an integer representing the number of variables (including constants) in the model.
                                Note that these are variables which might need calculation, but do not need integration.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">VARIABLE_INFO</literal> is an array of <literal classes="code">VariableInfoWithType</literal> dictionary, which contains:</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>a <literal classes="code">name</literal> field</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>a <literal classes="code">units</literal> field</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>a <literal classes="code">component</literal> field</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>a <literal classes="code">type</literal> enum field</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                        <list_item>
                            <paragraph>the <literal classes="code">VARIABLE_INFO</literal> array is <literal classes="code">VARIABLE_COUNT</literal> long.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <container classes="dothis">
                    <paragraph><strong>2.a</strong> Retrieve the number of variables from the generated module, and print the information related to each of them to the terminal.
                        If you aliased your imported module as <literal classes="code">model</literal> then these can be accessed using <literal classes="code">model.SOMETHING</literal>.</paragraph>
                </container>
                <paragraph>Secondly we have similar information items related to the state variables.
                    These are:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal classes="code">STATE_COUNT</literal> is an integer representing the number of state variables in the model.
                                These are the variables which need to be integrated.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">STATE_INFO</literal> is an array of dictionaries, with keys:</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>a <literal classes="code">name</literal> field</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>a <literal classes="code">units</literal> field</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>a <literal classes="code">component</literal> field</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                        <list_item>
                            <paragraph>the <literal classes="code">STATE_INFO</literal> array is <literal classes="code">STATE_COUNT</literal> long.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <container classes="dothis">
                    <paragraph><strong>2.b</strong> Retrieve the number of state variables from the generated code, and print the information related to each of them to the terminal.</paragraph>
                </container>
                <paragraph>The final information stored is the name and attributes of the base integration variable (variable of integration, VOI).
                    This is stored in <literal classes="code">VOI_INFO</literal>, a dictionary with the same keys as the <literal classes="code">STATE_INFO</literal> dictionaries.</paragraph>
                <container classes="dothis">
                    <paragraph><strong>2.c</strong> Retrieve the information about the VOI and print it to the terminal.</paragraph>
                </container>
            </section>
        </section>
        <section ids="investigate-the-functions-provided-in-the-generated-files" names="3:\ investigate\ the\ functions\ provided\ in\ the\ generated\ files">
            <title refid="id4">3: Investigate the functions provided in the generated files</title>
            <paragraph>As well as the information items, the generated module also contains functions which are derived from the governing equations in the MathML blocks in the original CellML model.</paragraph>
            <paragraph>In order to perform any kind of numerical integration, a solver needs three things:</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>An array of the current values of all state variables;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A way to update the gradient function of each of the state variables as the solution progresses; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A method to move from the current solution position to the next one.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <section ids="allocating-arrays" names="allocating\ arrays">
                <title refid="id5">Allocating arrays</title>
                <paragraph>Because we’re writing this tutorial based around a general situation, we can use the helper functions provided to allocate these arrays to the right size.
                    These are:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal classes="code">create_states_array</literal> will allocate an array of length <literal classes="code">STATE_COUNT</literal> and values of <literal classes="code">nan</literal>.
                                This can be used to allocate the array of rates too.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">create_variable_array</literal> will allocate an array of length <literal classes="code">VARIABLE_COUNT</literal> and values of <literal classes="code">nan</literal>.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <container classes="dothis">
                    <paragraph><strong>3.a</strong> Allocate three arrays: one for the state variables, one for the rates, and one for the variables.</paragraph>
                </container>
            </section>
            <section ids="defining-the-initial-values" names="defining\ the\ initial\ values">
                <title refid="id6">Defining the initial values</title>
                <paragraph>After allocating these arrays, we need to fill them with the information.
                    In <reference internal="True" refuri="../tutorial3/outline3#tutorial3"><inline classes="std std-ref">Tutorial 3</inline></reference> we used three equations to define this model:</paragraph>
                <math_block docname="tutorials/tutorial4/tutorial4_py" label="True" nowrap="False" number="True" xml:space="preserve">\frac{dy_s}{dt} =f(sharks, fishes, time) = a y_s + b y_s y_f

\frac{dy_f}{dt} =f(sharks, fishes, time) = c y_f + d y_s y_f

c = a - 2.0</math_block>
                <paragraph>with constants <math>(a, b, d)=(1.2, -0.6, 0.3)</math> and initial condtions of <math>y_s(t=0)=2.0</math> and <math>y_f(t=0)=1.0</math>.</paragraph>
                <paragraph>If you look inside the module file which was generated in the last tutorial you’ll see:</paragraph>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Inside the generated "tutorial3_PredatorPrey_generated.py" file:

def initialize_states_and_constants(states, variables):
  states[0] = 2.0
  states[1] = 1.0
  variables[0] = 1.2
  variables[1] = -0.6
  variables[2] = 0.3</literal_block>
                <paragraph>From here we can see the correlation with the initial conditions we specified in Tutorial 3, and the equations above.</paragraph>
                <container classes="dothis">
                    <paragraph><strong>3.b</strong> Call the <literal classes="code">initialize_states_and_constants</literal> function to initalise some of the arrays you created earlier.  Print them to the terminal for checking.</paragraph>
                </container>
                <container classes="nb">
                    <paragraph>Calling the <literal classes="code">initialize_states_and_constants</literal> function does not set the initial value of the other <literal classes="code">Variable</literal> objects.</paragraph>
                </container>
                <paragraph>Printing to the terminal should show you that while the CellML <literal classes="code">Variable</literal> items representing states and constants for which we specified an initial value have been applied, the constant <literal classes="code">c</literal> has not yet been evaluated.
                    There’s a second helper function <literal classes="code">compute_computed_constants(variables)</literal> which will do this for you.</paragraph>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Inside the generated "tutorial3_PredatorPrey_generated.py" file:
def compute_computed_constants(variables):
  variables[3] = variables[0]-2.0</literal_block>
                <container classes="dothis">
                    <paragraph><strong>3.c</strong> Call the <literal classes="code">compute_computed_constants</literal> function, and reprint the variables array to the terminal to check that the initial values for all variables have now been set correctly.</paragraph>
                </container>
                <paragraph>Now we’re ready to begin solving the model.</paragraph>
            </section>
        </section>
        <section ids="iterate-through-the-solution" names="4:\ iterate\ through\ the\ solution">
            <title refid="id7">4: Iterate through the solution</title>
            <paragraph>You can make use of the <reference internal="False" refuri="https://github.com/hsorby/cellsolver">cellsolver package</reference> to solve the generated model, or follow the simple steps below to write your own solver instead.</paragraph>
            <paragraph>This part will make use of a simple routine to step through the solution iterations using the Euler method to update the state variables.
                Following initialisation of some solution controls (time step, end point) there are three general parts to each iteration:</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Computing the variables at the current timestep;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Computing the gradient functions or rates at the current timestep;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Updating the state variables using an Euler* step.
                            * Note that this could be any stepping method - we just use this one as it’s very simple.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Define some variables to control the total number of steps to take, and the size that those steps should be.
                    In this example it’s safe to use a step of 0.001 and an end time of 20.</paragraph>
                <paragraph><strong>4.b</strong> Create a file for output and open it.
                    We’ll simply write the solution directly to the file instead of allocating memory for storage.
                    Name your columns with VOI and the state variable names and units.</paragraph>
            </container>
            <section ids="specification-of-the-variables" names="specification\ of\ the\ variables">
                <title refid="id8">Specification of the variables</title>
                <paragraph>In each iteration the variables may need to be updated.
                    In our example we do not have any dependencies (that is, <math>a, b, c, d</math> are constants) so the function which updates them is blank here, but this is not true of the general case.</paragraph>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Inside the generated "tutorial3_PredatorPrey_generated.py" file
def compute_variables(voi, states, rates, variables):
  pass</literal_block>
            </section>
            <section ids="specification-of-states-and-rates" names="specification\ of\ states\ and\ rates">
                <title refid="id9">Specification of states and rates</title>
                <paragraph>Once a <literal classes="code">Variable</literal> has been identified as a <emphasis>state</emphasis> variable, it is paired by the <literal classes="code">Generator</literal> by its corresponding entry in the <literal classes="code">rates</literal> array, which represents its gradient function.</paragraph>
                <paragraph>Because the gradients of each of the integrated variables or <literal classes="code">states</literal> could include dependency on time or any variable value, it must be updated throughout the solution process.
                    This is done by calling the <literal classes="code">computeRates</literal> function to recalculate the rates for each state variable.</paragraph>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Inside the generated "tutorial3_PredatorPrey_generated.py" file:

def compute_rates(voi, states, rates, variables):
  # The "rates" array contains the gradient functions for each of the variables
  # which are being integrated (the "states").

  # This equation is the equivalent of d(sharks)/dt = a*y_sharks + b*y_sharks*y_fishes.
  rates[0] = variables[0]*states[0]+variables[1]*states[0]*states[1]

  # This equation is the equivalent of d(fishes)/dt = c*y_fishes + d*y_sharks*y_fishes.
  rates[1] = variables[3]*states[1]+variables[2]*states[0]*states[1]</literal_block>
                <paragraph><strong>TODO</strong> Check which order to call these in? rates or variables first?</paragraph>
                <container classes="dothis">
                    <paragraph><strong>4.c</strong> Iterate through the time interval <math>[0,20]</math> and update the state variables using the Euler update method: <literal classes="code">y[n+1] = y[n] + y'[n]*stepSize</literal>.
                        At each step you will need to:</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Recompute the variables;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Recompute the rates;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Compute the state variables using the update method above; and</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Write to the file.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </container>
            </section>
        </section>
        <section ids="output" names="5:\ output">
            <title refid="id10">5: Output</title>
            <container classes="dothis">
                <paragraph><strong>5.a</strong> You can retrieve your solution from the file you’ve written for plotting in your program of choice.
                    If all has gone well you should see something similar to that shown in <literal classes="xref std std-numref">sharks_and_fish</literal> below.</paragraph>
            </container>
            <figure align="center" ids="sharks-and-fish" names="sharks_and_fish">
                <image alt="Euler solution to the predator-prey model" candidates="{'*': 'tutorials/tutorial4/../images/sharks_and_fish.png'}" uri="tutorials/tutorial4/../images/sharks_and_fish.png"></image>
                <caption>Euler solution to the predator-prey population model.</caption>
            </figure>
            <container classes="dothis">
                <paragraph><strong>5.b</strong> Go and have a cuppa, you’re done!</paragraph>
            </container>
        </section>
    </section>
</document>
