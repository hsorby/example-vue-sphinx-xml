<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="/Users/hsor001/Projects/Webstorm/test-sphinx/docs/tutorials/tutorial3/tutorial3_cpp.rst">
    <target refid="tutorial3-cpp"></target>
    <section ids="tutorial-3-c-creating-a-model-using-the-api tutorial3-cpp" names="tutorial\ 3\ c++:\ creating\ a\ model\ using\ the\ api tutorial3_cpp">
        <title>Tutorial 3 C++: Creating a model using the API</title>
        <paragraph>The outline for this tutorial is shown on the <reference internal="True" refuri="outline3#tutorial3"><inline classes="std std-ref">Tutorial 3</inline></reference> page.
            These are the C++ instructions.
            For the same tutorial in Python please see the <reference internal="True" refuri="../tutorial2/tutorial2_py#tutorial2-py"><inline classes="std std-ref">Tutorial 3 in Python</inline></reference> page instead.</paragraph>
        <paragraph><strong>Requirements</strong></paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><download_reference filename="8e552cfaaf187c985680b6b3c5e7ef46/CMakeLists.txt" refdoc="tutorials/tutorial3/tutorial3_cpp" refdomain="" refexplicit="False" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file for building this tutorial</paragraph>
            </list_item>
            <list_item>
                <paragraph><download_reference filename="bb0b7240eb32c2dee08557a0e13a919e/tutorial3.cpp" refdoc="tutorials/tutorial3/tutorial3_cpp" refdomain="" refexplicit="False" reftarget="tutorial3.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial3.cpp</literal></download_reference> Either the skeleton code, or ..</paragraph>
            </list_item>
            <list_item>
                <paragraph><download_reference filename="5b20da741ccbfe1dd650e25fde54649d/tutorial3_complete.cpp" refdoc="tutorials/tutorial3/tutorial3_cpp" refdomain="" refexplicit="False" reftarget="tutorial3_complete.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial3_complete.cpp</literal></download_reference> the completed tutorial code</paragraph>
            </list_item>
        </bullet_list>
        <topic classes="contents local" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="step-0-setup">Step 0: Setup</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="step-1-set-up-the-governing-equations">Step 1: Set up the governing equations</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id3" refid="step-2-create-the-variables">Step 2: Create the variables</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="step-3-built-in-and-customised-units">Step 3: Built-in and customised units</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id5" refid="step-4-use-code-generation-to-change-the-output-langauge">Step 4: Use code generation to change the output langauge</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="step-0-setup" names="step\ 0:\ setup">
            <title refid="id1">Step 0: Setup</title>
            <paragraph>Navigate into the <literal classes="code">tutorial3</literal> folder and check that you can build the template against the libCellML library successfully:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">cmake -DINSTALL_PREFIX=../../install .
make -j</literal_block>
            <paragraph>Running the template:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">./tutorial3</literal_block>
            <paragraph>… should give the output:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">---------------------------------------------------------------
    TUTORIAL 3: MODEL CREATION AND CODE GENERATION WITH THE API
---------------------------------------------------------------</literal_block>
        </section>
        <section ids="step-1-set-up-the-governing-equations" names="step\ 1:\ set\ up\ the\ governing\ equations">
            <title refid="id2">Step 1: Set up the governing equations</title>
            <paragraph>Just as you did in <reference internal="True" refuri="../tutorial2/tutorial2_cpp#tutorial2-cpp"><inline classes="std std-ref">Tutorial 2</inline></reference>, we need to start by setting up a <literal classes="code">Model</literal> instance, and creating a <literal classes="code">Component</literal> inside it.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> Create a new <literal classes="code">Model</literal> using the <literal classes="code">auto something = libcellml::Something::create("myThingName");</literal> idiom to create and name your model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> Create a new <literal classes="code">Component</literal> as above with a name, and add it to the model you created in 1.a.
                    This will be the integrator of the equations.</paragraph>
            </container>
            <paragraph>Now for the real bit.
                In order to actually model anything, we need to include the mathematical equations which represent the phyiscal situation of interest.
                As you saw in <reference internal="True" refuri="../tutorial2/tutorial2_cpp#tutorial2-cpp"><inline classes="std std-ref">Tutorial 2</inline></reference>, the maths and the <literal classes="code">Variable</literal> items which it references live inside a parent <literal classes="code">Component</literal> item.
                At this point it should be noted that the <emphasis>order</emphasis> in which you add your components, or models, or variables (or anything) is not important to the final product, but it <emphasis>can</emphasis> affect how quickly you’re able to find and fix bugs along the way.
                In these tutorials, we have suggested that you add the mathematics first and use a <literal classes="code">Validator</literal> to notify you of the
                outstanding items, but you can really do this in any order you choose.</paragraph>
            <paragraph>The system of equations which describe the populations are given by:</paragraph>
            <math_block docname="tutorials/tutorial3/tutorial3_cpp" label="True" nowrap="False" number="True" xml:space="preserve">c = a + 2.0

\frac{dy_s}{dt} =f(sharks, fish, time) = a y_s + b y_s y_f

\frac{dy_f}{dt} =f(sharks, fish, time) = c y_f + d y_s y_f</math_block>
            <paragraph>where <math>y_s</math> and <math>y_f</math> are the number of sharks and thousands of fish respectively, and the constants <math>(a, b, d)=(-0.8, 0.3, -0.6)</math> govern their behaviour.
                It’s clear that the value of constant <math>c</math> is easily calculable from the first equation, but we will leave it in this form
                to better illustrate the operation of the <literal classes="code">Generator</literal> later on.</paragraph>
            <paragraph>In order to use this in our model we need to write it as a MathML2 string.
                The basic structure for these is described in the <reference internal="False" refuri="https://www.w3.org/TR/MathML2/chapter4.html#id.4.2.1.3">W3 resource pages regarding MathML2</reference>.</paragraph>
            <container classes="nb">
                <paragraph><strong>Note</strong> that libCellML will <strong>only</strong> accept MathML2 markup, even though later versions (3 and 4) are now available.</paragraph>
            </container>
            <paragraph>Looking at the top equation first, the MathML2 representation of <math>c = a - 2.0</math> is:</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;apply&gt;&lt;eq/&gt;
   &lt;ci&gt;c&lt;/ci&gt;
   &lt;apply&gt;&lt;plus/&gt;
       &lt;ci&gt;a&lt;/ci&gt;
       &lt;cn&gt;2.0&lt;/cn&gt;
   &lt;/apply&gt;
&lt;/apply&gt;</literal_block>
            <paragraph>Four things can be seen here:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The <literal classes="code">&lt;apply&gt;</literal> opening and <literal classes="code">&lt;/apply&gt;</literal> closing tags which surround the <emphasis>operations</emphasis>;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <emphasis>operations</emphasis> tags like <literal classes="code">&lt;eq/&gt;</literal> and <literal classes="code">&lt;plus/&gt;</literal> (or <literal classes="code">&lt;minus/&gt;</literal>, <literal classes="code">&lt;times/&gt;</literal>, <literal classes="code">&lt;divide/&gt;</literal>) which stand alone rather than in an open/close pair;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal classes="code">&lt;ci&gt;</literal> opening and <literal classes="code">&lt;/ci&gt;</literal> closing tags which surround the variable names; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal classes="code">&lt;cn&gt;</literal> opening and <literal classes="code">&lt;/cn&gt;</literal> closing tags which surround the constant <math>2.0</math> value.</paragraph>
                </list_item>
            </bullet_list>
            <container classes="dothis">
                <paragraph><strong>1.c</strong> Create a string containing the MathML which represents equation 1 above.</paragraph>
            </container>
            <paragraph>Differential terms, such as those on the left-hand side of equations 2 and 3 <math>\frac{dx}{dt}</math> in MathML become:</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;apply&gt;&lt;diff/&gt;
    &lt;bvar&gt;
        &lt;ci&gt;t&lt;/ci&gt;
    &lt;/bvar&gt;
    &lt;ci&gt;x&lt;/ci&gt;
&lt;/apply&gt;</literal_block>
            <paragraph>Two further items to note:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The base variable for the integration is identified by the <literal classes="code">&lt;bvar&gt; ... &lt;/bvar&gt;</literal> tags.
                        These variables are refered to as <emphasis>variables of integration</emphasis> or <emphasis>base variables</emphasis>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal classes="code">&lt;diff/&gt;</literal> operation signifies differentiation with respect to the base variable.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The right-hand side becomes a collection of nested operations, all bracketed by <literal classes="code">&lt;apply&gt;...&lt;/apply&gt;</literal> tags for each operation:</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;apply&gt;&lt;plus/&gt;
  &lt;apply&gt;&lt;times/&gt;
    &lt;ci&gt;a&lt;/ci&gt;
    &lt;ci&gt;y_s&lt;/ci&gt;
  &lt;/apply&gt;
  &lt;apply&gt;&lt;times/&gt;
    &lt;ci&gt;b&lt;/ci&gt;
    &lt;ci&gt;y_s&lt;/ci&gt;
    &lt;ci&gt;y_f&lt;/ci&gt;
  &lt;/apply&gt;
&lt;/apply&gt;</literal_block>
            <paragraph>When both sides are defined we need to equate them by <literal classes="code">&lt;apply&gt;</literal> -ing the <literal classes="code">&lt;eq/&gt;</literal> equals operator, and create a string so that we end up with:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">std::string equation2 =
    "&lt;apply&gt;&lt;eq/&gt;"
    "   &lt;apply&gt;&lt;diff/&gt;"
    "     &lt;bvar&gt;&lt;ci&gt;time&lt;/ci&gt;&lt;/bvar&gt;"
    "     &lt;ci&gt;y_s&lt;/ci&gt;"
    "   &lt;/apply&gt;"
    "   &lt;apply&gt;&lt;plus/&gt;"
    "       &lt;apply&gt;&lt;times/&gt;"
    "           &lt;ci&gt;a&lt;/ci&gt;"
    "           &lt;ci&gt;y_s&lt;/ci&gt;"
    "      &lt;/apply&gt;"
    "      &lt;apply&gt;&lt;times/&gt;"
    "          &lt;ci&gt;b&lt;/ci&gt;"
    "          &lt;ci&gt;y_s&lt;/ci&gt;"
    "          &lt;ci&gt;y_f&lt;/ci&gt;"
    "      &lt;/apply&gt;"
    "   &lt;/apply&gt;"
    "&lt;/apply&gt;";</literal_block>
            <container classes="dothis">
                <paragraph><strong>1.d</strong> Copy the string above representing equation 2 into your code.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.e</strong> Create a third string representing equation 3.</paragraph>
            </container>
            <paragraph>Next you need to define the namespace in which the maths will be applied by enclosing it in the <literal classes="code">&lt;math&gt; ... &lt;/math&gt;</literal> tags with the two namespaces:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>the MathML2 namespace <literal classes="code">xmlns</literal> at <reference refuri="http://www.w3.org/1998/Math/MathML">http://www.w3.org/1998/Math/MathML</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph>the CellML2 namespace <literal classes="code">xmlns:cellml</literal> at <reference refuri="http://www.cellml.org/cellml/2">http://www.cellml.org/cellml/2</reference>.0#</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>It’s simple to do this once in your code using a string to represent the opening attributes and namespaces; this string can be reused easily throughout your code as needed later:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">std::string mathHeader = "&lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\"\
                                xmlns:cellml=\"http://www.cellml.org/cellml/2.0#\"&gt;";
std::string mathFooter = "&lt;/math&gt;";</literal_block>
            <container classes="dothis">
                <paragraph><strong>1.f</strong> Copy the opening and closing math strings above into your code.</paragraph>
            </container>
            <paragraph>Our last step in defining the mathematics is to link it into the component.
                The functions available to manipulate maths are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>A <literal classes="code">setMath(yourMathsHere)</literal> function, which overwrites any existing MathML strings
                        stored in the <literal classes="code">Component</literal> item;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>An <literal classes="code">appendMath(yourMathsHere)</literal> function, which performs a straightforward string
                        concatenation with the current contents of the maths string in the
                        <literal classes="code">Component</literal>; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A <literal classes="code">clearMath()</literal> function to remove all maths contents.</paragraph>
                </list_item>
            </bullet_list>
            <container classes="dothis">
                <paragraph><strong>1.g</strong>
                    Use the functions above to include the <literal classes="code">mathHeader</literal>, <literal classes="code">equation</literal>, and <literal classes="code">mathFooter</literal> strings into your component.</paragraph>
            </container>
            <container classes="nb">
                <paragraph>Note that the order in which strings are added might be important, as they are stored as a single concatenated string.
                    However, the order in which complete MathML equations occur in the overall MathML string is not important.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.h</strong> Create a <literal classes="code">Validator</literal> and use it to check for errors in the model at this point.
                    Use the utility function <literal classes="code">printErrorsToTerminal</literal> to output the messages to the terminal.</paragraph>
            </container>
            <paragraph>You should see an output similar to that shown below:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">The validator has found 18 errors!
  Validator error[0]:
    Description: MathML ci element has the child text 'c' which does not correspond with any variable
    names present in component 'predator_prey_component'.
  ...
  Validator error[3]:
    Description: Math cn element with the value '2.0' does not have a valid cellml:units attribute.
  ...</literal_block>
            <paragraph>Running the validator will alert you variables in the MathML that don’t (yet) exist in your component.
                This was explained in <reference internal="True" refuri="../tutorial2/tutorial2_cpp#tutorial2-cpp"><inline classes="std std-ref">Tutorial 2</inline></reference>.</paragraph>
        </section>
        <section ids="step-2-create-the-variables" names="step\ 2:\ create\ the\ variables">
            <title refid="id3">Step 2: Create the variables</title>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Create <literal classes="code">Variable</literal> items for each of the missing variables discovered above.
                    Remember that:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Each must have a name, either using the naming constructor <literal classes="code">Variable::create("myNewVariable")</literal> or by manually calling the <literal classes="code">setName</literal> function; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Each name must match that inside your MathML string.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Add each of your new variables to the component using the <literal classes="code">addVariable(myNewVariable)</literal> function.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Call the validator again to check for errors.
                    At this stage you can expect errors like those below relating to missing units for the variables.
                    Note that both these errors refer to the same thing: when the unit is missing the variable sees its name field as being blank, hence the first error.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">Validator error[0]:
  Description: CellML identifiers must contain one or more basic Latin :term:`alphabetic&lt;Basic Latin alphabetic character&gt;` characters.
    See section 3.1.3 in the CellML specification.
Validator error[1]:
  Description: Variable 'a' does not have a valid units attribute.
    See section 11.1.1.2 in the CellML specification.</literal_block>
        </section>
        <section ids="step-3-built-in-and-customised-units" names="step\ 3:\ built-in\ and\ customised\ units">
            <title refid="id4">Step 3: Built-in and customised units</title>
            <paragraph>Linking variables to the <emphasis>name</emphasis> of their units is straightforward, but in order to be able to use them we need to also define what the name actually <emphasis>means</emphasis> by creating the units themselves.
                Some basic units have been defined and built into libCellML, others you can define by combining the built-in ones using scaling factors and exponents, or you can define your own from scratch if need be.</paragraph>
            <container classes="toggle">
                <container classes="header">
                    <paragraph>Read more about units</paragraph>
                </container>
                <container classes="infospec">
                    <paragraph>Linking variables to the <emphasis>name</emphasis> of their units is straightforward, but in order to be able to use them we need to also define what the name actually <emphasis>means</emphasis> by creating the units themselves.
                        Some basic units have been defined and built into libCellML, others you can define by combining the built-in ones using scaling factors and exponents, or you can define your own from scratch if need be.</paragraph>
                    <paragraph>There are four different kinds of units used here: irreducible units, built-in units, derived or combination units, and custom irreducible units.</paragraph>
                    <paragraph>The first are called <emphasis>irreducible</emphasis> because they represent the physical base quantities which cannot be further simplified:</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>length (<literal classes="code">metre</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>time (<literal classes="code">second</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>amount of a substance (<literal classes="code">mole</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>temperature (<literal classes="code">kelvin</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>mass (<literal classes="code">kilogram</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>electrical current (<literal classes="code">ampere</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>luminous intensity (<literal classes="code">candela</literal>)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>non-dimensional (<literal classes="code">dimensionless</literal>)</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>These <emphasis>irreducible</emphasis> units can be used to create all other physically-based units by combining them using different exponents, multipliers, and prefixes.</paragraph>
                    <paragraph>Some of these combinations form our second type of units, the <emphasis>built-in units</emphasis>, these being common relationships which have been constructed from combinations of the irreducible units.
                        The combinations can involve:</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>A scaling factor (the units <literal classes="code">millisecond</literal> is equivalent to
                                <literal classes="code">second</literal> and a factor of 0.001);</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>A combination of units (a <literal classes="code">coulomb</literal> is a <literal classes="code">second</literal> multiplied by
                                an <literal classes="code">ampere</literal>);</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Powers of units (a <literal classes="code">Hertz</literal> has a base of <literal classes="code">second</literal> with an
                                exponent of -1); and</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Any combination of the above.</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>A list of pre-existing <emphasis>built-in</emphasis> convenience units is shown in the <inline classes="xref std std-ref">Built-in Units page</inline>, along with their relationships to the irreducible units.</paragraph>
                    <paragraph>The third type of units are those <emphasis>combinations</emphasis> which users can define for themselves based on the built-in units, the irreducible units, any other units already created, or (see below) their own custom irreducible units.</paragraph>
                    <paragraph>For example, let’s say that you want to simulate the time variable, <math>t</math>, in units of milliseconds.
                        This isn’t one of the built-in units, so you’ll need to define it, but it’s easy to see that it’s based on the built-in <literal classes="code">second</literal>, but needs a scaling factor.</paragraph>
                    <paragraph>For convenience libCellML gives a variety of options for defining such scaling factors:</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>Either through the use of named prefixes which are listed on the <inline classes="xref std std-ref">Prefix page</inline>, eg: <literal classes="code">millisecond</literal> is <literal classes="code">second</literal> with <literal classes="code">prefix="milli"</literal>;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>By defining an integer or integer string as a prefix which represents the <math>log_{10}</math> of the scaling factor, eg: <literal classes="code">millisecond</literal> is <literal classes="code">second</literal> with <literal classes="code">prefix=-3</literal> gives a scaling factor of <math>10^{-3}=0.001</math>.
                                NB: using an integer string like <literal classes="code">prefix="-3"</literal> gives the same result; and</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>By defining the scaling factor directly, as a multiplier, eg: <literal classes="code">millisecond</literal> is <literal classes="code">second</literal> with <literal classes="code">multiplier=0.001</literal>.</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>The overloaded argument option list is shown below for each language:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">**TODO** Check that this is correct ... ??!!

void addUnit(const std::string &amp;reference, const std::string &amp;prefix, double exponent = 1.0,
             double multiplier = 1.0, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference, Prefix prefix, double exponent = 1.0,
             double multiplier = 1.0, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference, int prefix, double exponent,
             double multiplier = 1.0, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference, double exponent, const std::string &amp;id = "");

void addUnit(const std::string &amp;reference);</literal_block>
                    <paragraph>Note that <literal classes="code">reference</literal> can be another unit name string or a <literal classes="code">StandardUnits</literal> enum, and <literal classes="code">prefix</literal> can be a string or an integer.</paragraph>
                    <paragraph>To create a <literal classes="code">Units</literal> item you need will follow the same basic steps as other entities: declare it, name it, define it, and then add it in.
                        For example:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Declare, name, and define a "millisecond" unit pointer.
auto ms = libcellml::Units::create("millisecond");

// The manner of specification here is agnostic: all three definitions are identical.
ms-&gt;addUnit("second", "milli");  // reference unit and built-in prefix
// OR
ms-&gt;addUnit("second", 1.0, -3);  // reference unit, multiplier, exponent
// OR
ms-&gt;addUnit("second", 1.0, 0, 0.001);  // reference unit, multiplier, exponent</literal_block>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">from libcellml import Units

# Declare, name, and define a "millisecond" unit pointer.
ms = Units("millisecond")

# The manner of specification here is agnostic: all three definitions are identical.
ms.addUnit("second", "milli")          # reference unit and built-in prefix
# OR
ms.addUnit("second", -3, 0.001)        # reference unit, exponent, multiplier
# OR
ms.addUnit("second", 1, 1.0, 0.01)     # reference unit, prefix, exponent, multiplier</literal_block>
                    <paragraph>Units can be defined based on one another as well.
                        For example, after defining our <literal classes="code">millisecond</literal> units, we could then use this definition to define the <literal classes="code">per_millisecond</literal> units by simply including it with an exponent of -1:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Define a per_millisecond unit based on millisecond^-1:
per_ms-&gt;addUnit(ms, -1.0);</literal_block>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Defining a per_millisecond unit based on millisecond^-1.
per_ms.addUnit(ms, -1.0)  # reference unit, exponent</literal_block>
                    <paragraph>The final type of unit is a custom irreducible unit.
                        While this is not common in purely physical models (all of the seven physical attributes are already included), for times when you’re modelling something non-physical (such as our numbers of sharks or fishes), you’re able to define your own.
                        Here’s an example.</paragraph>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Create a custom irreducible unit named "banana".
auto uBanana = libcellml::Units::create("banana");

// Note that when a UnitsPtr is defined with a name only (that is, without any
// calls to the addUnit(...) function), it is effectively irreducible.

// Create a new compound unit based on the "banana" unit above.
auto uBunchOfBananas = libcellml::Units::create("bunch_of_bananas");
u2-&gt;addUnit("banana", 5.0);  // include bananas^5 in the bunch_of_bananas unit</literal_block>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">from libcellml import Units

# Create a custom irreducible unit named "banana".
uBanana = Units("banana")

# Note that when a Units is defined with a name only, it is effectively irreducible.

# Create a new compound unit based on the "banana" unit above.
uBunchOfBananas = Units("bunch_of_bananas")
uBunchOfBananas.addUnit("banana", 5.0)  # include bananas^5 in the bunch_of_bananas unit</literal_block>
                </container>
            </container>
            <paragraph>To create a <literal classes="code">Units</literal> item you need will follow the same basic steps as other entities: declare it, name it, define it, and then add it in.
                For example:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Declare, name, and define a "millisecond" unit pointer.
auto ms = libcellml::Units::create("millisecond");

// The manner of specification here is agnostic: all three definitions are identical.
ms-&gt;addUnit("second", "milli");  // reference unit and built-in prefix
// OR
ms-&gt;addUnit("second", 1.0, -3);  // reference unit, multiplier, exponent
// OR
ms-&gt;addUnit("second", 1.0, 0, 0.001);  // reference unit, multiplier, exponent</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Use the example above to create, name and define the units of “month” which will represent your time variable.  This should be defined as a multiple of the built-in unit <literal classes="code">second</literal>.</paragraph>
            </container>
            <paragraph>Units can be defined based on one another as well.
                For example, after defining our <literal classes="code">millisecond</literal> units, we could then use this definition to define the <literal classes="code">per_millisecond</literal> units by simply including it with an exponent of -1:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Define a per_millisecond unit based on millisecond^-1:
per_ms-&gt;addUnit(ms, -1.0);</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> Create a <literal classes="code">Units</literal> item called “per_month” based on the one you just created, as shown above.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Create the irreducible units needed by the shark and fish populations.
                    Call these “number_of_sharks” and “thousands_of_fish” respectively.</paragraph>
            </container>
            <paragraph>Finally we need to create the units for the constants <literal classes="code">b</literal> and <literal classes="code">d</literal>.
                These will be combinations of those which we’ve already created, as defined by the need for dimensional consistency in our governing equations.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.d</strong> Create two units representing “per shark month” (for the <literal classes="code">b</literal> variable) and “per fish month” (for the <literal classes="code">d</literal> variable).</paragraph>
            </container>
            <paragraph>The final two steps are to associate each variable with its appropriate units, and to include the units in the model.</paragraph>
            <container classes="nb">
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>When you add different sub-unit parts into a <literal classes="code">Units</literal> item, the function is <literal classes="code">addUnit</literal> (singular), and it takes as argument the <emphasis>name</emphasis> of the sub-unit as a string (eg: <literal classes="code">"second"</literal> used above).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>When you add the final created combination into the <literal classes="code">Model</literal> item, the function is <literal classes="code">addUnits</literal> (plural), and it takes as argument the <emphasis>reference</emphasis> of the combined units (eg: <literal classes="code">ms</literal>).</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.e</strong> Add the units to their variables using <literal classes="code">myVariable-&gt;setUnits(myUnits)</literal>.
                    Add the units to the model using <literal classes="code">myModel-&gt;addUnits(myUnits)</literal>.</paragraph>
            </container>
            <container classes="nb">
                <paragraph><strong>Gotcha!</strong> When you specify the <literal classes="code">Units</literal> for a <literal classes="code">Variable</literal> using its name then you may need to call the <literal classes="code">Model::linkUnits()</literal> function before validating the model.
                    If you see errors related to missing units which do in fact exist, then a call to the <literal classes="code">Model::linkUnits()</literal> function is needed.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.f</strong> Call the validator to check your model for errors.
                    You should see an output similar to that shown below.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">The validator has found 2 errors!
  Validator error[0]:
    Description: CellML identifiers must contain one or more basic Latin characters.
    See section 3.1.3 in the CellML specification.
  Validator error[1]:
    Description: Math cn element with the value '2.0' does not have a valid cellml:units attribute.</literal_block>
            <paragraph>These messages are really referring to just one issue.
                In the first MathML equation we used a real number <literal classes="code">&lt;cn&gt;2.0&lt;/cn&gt;</literal> without specifying any units for it.</paragraph>
            <paragraph>Because the dimensionality of the equation needs to be valid, all real numbers must be associated with units, just the same way that variables are.
                These are defined within the tags of the MathML, and must also refer to the <literal classes="code">cellml</literal> namespace.  For example:</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;cn cellml:units="bunch_of_bananas"&gt;1&lt;/cn&gt;</literal_block>
            <paragraph>… which gives us one bunch of bananas, without needing to create a corresponding <literal classes="code">Variable</literal> item.
                Of course, you may need to create the corresponding <literal classes="code">Units</literal> item and add it to the model, if it is not already present.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.g</strong>  Create a copy of the MathML statement from step 1.c and add the namespace and units definition as in the example above into the string.
                    Recall that using the <literal classes="code">setMath()</literal> function will overwrite the existing maths, and repeat the process you did in step 1.e to include the new MathML instead.
                    Remember that you will need to reinclude the opening and closing <literal classes="code">&lt;math&gt;</literal> tags and other equations too.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.h</strong> Check that the model is now free of validation errors.</paragraph>
            </container>
        </section>
        <section ids="step-4-use-code-generation-to-change-the-output-langauge" names="step\ 4:\ use\ code\ generation\ to\ change\ the\ output\ langauge">
            <title refid="id5">Step 4: Use code generation to change the output langauge</title>
            <paragraph>Some exciting new functionality of libCellML is its ability to generate a runable file from a model description.
                This means that if you already have a solver in either C or Python, you can simply translate your model from here into that language.
                Let’s give it a go.</paragraph>
            <paragraph>The generator is instantiated in the same way as the other items:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Instantiate the generator and submit the model to it for processing.
auto generator=libcellml::Generator::create();
generator-&gt;processModel(model);</literal_block>
            <paragraph>The <literal classes="code">Generator</literal> has to re-interpret all of the maths, including the variables, their interaction with each other in different equations, values, initial conditions and units before it can output your model in your choice of language.
                For the maths to make sense, the definitions in your model’s variables, maths blocks and units need to be solvable too.
                There are several requirements that need to be satisfied in order for the code generation functionality to be able to work, <emphasis>beyond</emphasis> the CellML syntax requirements.
                These are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The mathematical model definition must be appropriately constrained (not over- or under-constrained);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Initial conditions must be specified for variables which are integrated; <strong>TODO</strong> need to elaborate …</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Initial conditions must not be specified for variables which are the base of integration;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The values of constants must be specified or calculable; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>TODO get full list of stuff here …</strong></paragraph>
                </list_item>
            </bullet_list>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Create a <literal classes="code">Generator</literal> instance and follow the example above to process your model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.b</strong> Call the utility function <literal classes="code">printErrorsToTerminal</literal> for your generator to check it.
                    You should see an output similar to that shown below.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">The generator has found 6 errors!
 Generator error[0]:
   Description: Variable 'a' in component 'predator_prey_component' of model 'tutorial_3_model'
   is not computed.
 Generator error[1]:
    Description: Variable 'b' in component 'predator_prey_component' of model 'tutorial_3_model'
    is not computed.
 Generator error[2]:
    Description: Variable 'c' in component 'predator_prey_component' of model 'tutorial_3_model'
    is not computed.
 Generator error[3]:
    Description: Variable 'd' in component 'predator_prey_component' of model 'tutorial_3_model'
    is not computed.
 Generator error[4]:
    Description: Variable 'y_f' in component 'predator_prey_component' of model 'tutorial_3_model'
    is used in an ODE, but it is not initialised.
 Generator error[5]:
    Description: Variable 'y_s' in component 'predator_prey_component' of model 'tutorial_3_model'
    is used in an ODE, but it is not initialised.</literal_block>
            <paragraph>The error messages above refer to the fact that though our model has passed validation tests, it’s not yet sufficiently constrained to allow it to be solved, which is what the <literal classes="code">Generator</literal> checks for.
                We need to set initial conditions for the variables we’re solving for, the populations of sharks and fish, using the <literal classes="code">setInitialValue</literal> function.
                The values of the constants <literal classes="code">a, b, c, d</literal> are just that - constant - and their values are set using the same <literal classes="code">setInitialValue</literal> function.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.c</strong> Set the values of the constants <math>(a, b, d)=(-0.8, 0.3, -0.6)</math> and the initial conditions such that <math>y_f(t=0)=2.0</math> and <math>y_s(t=0)=1.0</math>.
                    Note that:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>The constant <math>c</math> will be calculated by our equation 1, so does not need to be specified; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The base variable (or “variable of integration”, or “voi”) <math>t</math> must <emphasis>not</emphasis> have an initial condition set.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.d</strong> Reprocess the model and verify that the generator returns no errors.</paragraph>
            </container>
            <paragraph>Once the generator is happy we can use it to retrieve code generated according to the <literal classes="code">GeneratorProfile</literal>, either C or Python.
                Of course, your choice of generator profile (language) will affect <emphasis>what</emphasis> you need to export:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>If you’re using the C profile, then you will need both the header file as well as the source code.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If you’re using Python, you will only need the source code.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>By default the <literal classes="code">GeneratorProfile</literal> is set to C so we can use it as-is to generate implementation code (source code) and interface code (header code) like this:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Retrieve the interface or header code, and write to a file:
std::ofstream outFile("tutorial3_PredatorPrey_generated.h");
outFile &lt;&lt; generator-&gt;interfaceCode();
outFile.close();

// Retrieve the main source code and write to a file:
outFile.open("tutorial3_PredatorPrey_generated.c");
outFile &lt;&lt; generator-&gt;implementationCode();
outFile.close();</literal_block>
            <container classes="dothis">
                <paragraph><strong>4.e</strong> Use the examples above to create your own interface code (that is, the *.h file contents) and source code (that is, the *.c file contents) from your model, and save them into appropriately named files.</paragraph>
            </container>
            <paragraph>We can change the profile to Python using the following expression:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Change the generated language from the default C to Python.
auto profile =
    libcellml::GeneratorProfile::create(libcellml::GeneratorProfile::Profile::PYTHON);
generator-&gt;setProfile(profile);</literal_block>
            <container classes="dothis">
                <paragraph><strong>4.f</strong> Use the example above to change the generator profile to Python.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.g</strong> In the same way as earlier, retrieve the implementation code and write it to a Python file.
                    For the Python profile you will not need interface code.</paragraph>
            </container>
            <paragraph>Check that you have indeed created three new files.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.h</strong>
                    Go and have a cuppa, you’re done (for now).
                    The contents of these generated files and their usage is described in the next tutorial, <reference internal="True" refuri="../tutorial4/tutorial4_cpp#tutorial4-cpp"><inline classes="std std-ref">Tutorial 4</inline></reference>.</paragraph>
            </container>
        </section>
    </section>
</document>
