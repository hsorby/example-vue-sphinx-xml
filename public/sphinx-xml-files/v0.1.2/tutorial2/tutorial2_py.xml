<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="/Users/hsor001/Projects/Webstorm/test-sphinx/docs/tutorials/tutorial2/tutorial2_py.rst">
    <target refid="tutorial2-py"></target>
    <section ids="tutorial-2-python-debugging-error-checking-and-validating tutorial2-py" names="tutorial\ 2\ python:\ debugging,\ error\ checking\ and\ validating tutorial2_py">
        <title>Tutorial 2 Python: Debugging, error checking and validating</title>
        <paragraph>The outline for this tutorial is shown on the <reference internal="True" refuri="outline2#tutorial2"><inline classes="std std-ref">Tutorial 2</inline></reference> page.
            These are the Python instructions.
            For the same tutorial in C++ please see the <reference internal="True" refuri="tutorial2_cpp#tutorial2-cpp"><inline classes="std std-ref">Tutorial 2 C++</inline></reference> page instead.</paragraph>
        <paragraph><strong>Requirements</strong></paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><download_reference filename="0ec22c96b572783b093236ffc5955c8f/tutorial2.py" refdoc="tutorials/tutorial2/tutorial2_py" refdomain="" refexplicit="False" reftarget="tutorial2.py" reftype="download" refwarn="False"><literal classes="xref download">tutorial2.py</literal></download_reference> The skeleton code or: download:<title_reference>tutorial2_complete.py</title_reference> the completed tutorial code;</paragraph>
            </list_item>
            <list_item>
                <paragraph><download_reference filename="f172aae9610fc43fa15416ccd6a3abf8/tutorial2.cellml" refdoc="tutorials/tutorial2/tutorial2_py" refdomain="" refexplicit="False" reftarget="../resources/tutorial2.cellml" reftype="download" refwarn="False"><literal classes="xref download">../resources/tutorial2.cellml</literal></download_reference> The input CellML file to read; and</paragraph>
            </list_item>
            <list_item>
                <paragraph><download_reference filename="c4d8417414f9feeda9f14997e25637b3/tutorial_utilities.py" refdoc="tutorials/tutorial2/tutorial2_py" refdomain="" refexplicit="False" reftarget="../utilities/tutorial_utilities.py" reftype="download" refwarn="False"><literal classes="xref download">../utilities/tutorial_utilities.py</literal></download_reference> Utility functions for use in the tutorials.</paragraph>
            </list_item>
        </bullet_list>
        <topic classes="contents local" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="step-0-setup">Step 0: Setup</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="step-1-create-a-model-from-the-contents-of-a-cellml-file">Step 1: Create a <literal>Model</literal> from the contents of a CellML file</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id3" refid="step-2-print-the-contents-of-the-file-to-the-screen">Step 2: Print the contents of the file to the screen</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="step-3-fix-the-errors-that-were-reported">Step 3: Fix the errors that were reported</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id5" refid="step-4-have-a-look-at-the-corrected-model">Step 4: Have a look at the corrected model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id6" refid="step-5-serialise-and-output-the-model-to-a-file">Step 5: Serialise and output the model to a file</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="step-0-setup" names="step\ 0:\ setup">
            <title refid="id1">Step 0: Setup</title>
            <paragraph>For each of the tutorials, there is template code provided for you to get started in each of the <literal classes="code">tutorial*.py</literal> files.</paragraph>
            <container classes="dothis">
                <paragraph><strong>Setup</strong> Confirm that you’re able to run the <literal classes="code">tutorial2.py</literal> template against the libCellML library.
                    To run the skeleton code, navigate into the <literal classes="code">tutorials</literal> directory.
                    To run the completed tutorial, navigate into the <literal classes="code">tutorials_completed</literal> directory.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="default" linenos="False" xml:space="preserve">cd tutorials
python tutorial2.py</literal_block>
            <paragraph>This should give the output:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">-----------------------------------------------
  TUTORIAL 2: ERROR CHECKING AND VALIDATION
-----------------------------------------------</literal_block>
        </section>
        <section ids="step-1-create-a-model-from-the-contents-of-a-cellml-file" names="step\ 1:\ create\ a\ model\ from\ the\ contents\ of\ a\ cellml\ file">
            <title refid="id2">Step 1: Create a <literal>Model</literal> from the contents of a CellML file</title>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> As you did in <reference internal="True" refuri="../tutorial1/tutorial1_py#tutorial1-py"><inline classes="std std-ref">Tutorial 1</inline></reference>, use the <literal classes="code">Parser</literal> to create a model from the <literal classes="code">resources/tutorial2.cellml</literal> file provided.</paragraph>
            </container>
        </section>
        <section ids="step-2-print-the-contents-of-the-file-to-the-screen" names="step\ 2:\ print\ the\ contents\ of\ the\ file\ to\ the\ screen">
            <title refid="id3">Step 2: Print the contents of the file to the screen</title>
            <paragraph>Instead of duplicating the work you did throughout the middle steps of <reference internal="True" refuri="../tutorial1/tutorial1_py#tutorial1-py"><inline classes="std std-ref">Tutorial 1</inline></reference>, we’ve provided you with a set of utility functions in the <literal classes="code">tutorial_utilities.py</literal> file which will help with some of the repeated bits of these tutorials.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Use the utility function <literal classes="code">print_model_to_terminal(yourModelHere)</literal> to output the contents of the model you just created to the terminal so that you can see it properly.
                    You’ll need to first include the utility functions using <literal classes="code">from tutorial_utilities import print_model_to_terminal</literal>.</paragraph>
            </container>
            <paragraph>Within the libCellML library is the <literal classes="code">Validator</literal> class.
                This has one job - to make sure that what you give it is <emphasis>valid</emphasis> in terms of its CellML2.0 compliance.
                Does it mean that your simulations will work the way you expect?
                Nope, you can still write rubbish!
                You can think of the validation being the spell-checker for your model.
                It doesn’t judge the meaning of <emphasis>what</emphasis> you’ve written, just the nitty-gritty of <emphasis>how</emphasis> you’ve written it.</paragraph>
            <paragraph>The validator can also help you as you create and edit models by pointing out what’s missing or incorrect as you go.
                This is really easy:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">validator = libCellML.Validator()
validator-&gt;validateModel(yourModelHere)</literal_block>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Create a <literal classes="code">Validator</literal> and pass your model to it, as above.</paragraph>
            </container>
            <paragraph>When you’ve created a <literal classes="code">Validator</literal> object and called it to check a model, a record of any errors is stored inside the validator.
                To figure out what’s going on, you need to retrieve the pointers to these <literal classes="code">Issue</literal> objects.</paragraph>
            <paragraph>As in <reference internal="True" refuri="../tutorial1/tutorial1_py#tutorial1-py"><inline classes="std std-ref">Tutorial 1</inline></reference>, you can call a <literal classes="code">count</literal> function (in the case of a <literal classes="code">Validator</literal>, this is the <literal classes="code">errorCount()</literal> function to determine whether any errors have been raised.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Retrieve the number of errors from the validator, and print it to the terminal.</paragraph>
            </container>
            <paragraph>Now we need to create an iterative loop to retrieve all (and there should be a few in this particular model!) from the validator.
                Again following the same retrieval idiom as in <reference internal="True" refuri="../tutorial1/tutorial1_py#tutorial1-py"><inline classes="std std-ref">Tutorial 1</inline></reference> for items in sets, we can access the errors
                using an index:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">the_fifteenth_rror = validator-&gt;error(14)</literal_block>
            <paragraph>Inside an <literal classes="code">Issue</literal> structure are two fields which are really useful.
                These are the <literal classes="code">description()</literal> (which does what you’d think) and the <literal classes="code">referenceHeading()</literal>, which points you to the section in the CellML2.0 specification document for reference.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.d</strong> Create a loop (up to the number of errors found in 2.c), retrieve each error, and print their description and specification reference to the screen.  This is what we’ve used:</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">for e in range(0, number_of_validation_errors):
    # Retrieving the e-th error from the validator
    validator_error = validator-&gt;error(e)

    # Printing the description to the screen
    print("  Validator error[{e}]: ".format(e=e))
    print("     Description: " + validator_error.description())

    # Checking for a specification, and printing to the terminal if found
    specification_heading = validator_error.referenceHeading()
    if specification_heading != "":
        print("    See section {r} in the CellML specification.".format(
            r=specification_heading
            ))</literal_block>
        </section>
        <section ids="step-3-fix-the-errors-that-were-reported" names="step\ 3:\ fix\ the\ errors\ that\ were\ reported">
            <title refid="id4">Step 3: Fix the errors that were reported</title>
            <paragraph>As you go through these tutorials you should be able to compile and run your code at any stage.
                If you haven’t been doing so already, then do it now, and take a look at what you’ve printed.
                This section works through each of the errors found and shows you how to fix them.</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">Validator error[0]:
   Description: CellML identifiers must not begin with a European numeric character [0-9].
   See section 3.1.4 in the CellML specification.
Validator error[1]:
   Description: Variable does not have a valid name attribute.
   See section 11.1.1.1 in the CellML specification.</literal_block>
            <paragraph>These errors refer to the same thing, but are better read in reverse order.
                Variables (and everything else in CellML which specifies a name attribute) must have the correct format.
                Comparing the error to the names of entities printed in the terminal we can see that <literal classes="code">variable[0]</literal> in
                <literal classes="code">component[0]</literal> doesn’t have a valid name (because it starts with a European numeric character).
                Let’s fix that.</paragraph>
            <paragraph>Remembering from the last tutorial that we can access items through their indices, now we can use the <literal classes="code">setSomething(someValue)</literal> idiom to fix the variable name:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Access the 0th variable of the 0th component and set its name to "A".
your_model_here.component(0).variable(0).setName("A")</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Add the fix above and check that it has indeed removed those errors from the list reported.</paragraph>
            </container>
            <transition></transition>
            <paragraph>On to the next error.</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">Validator error[2]:
   Description: Variable 'b' has an invalid units reference 'i_am_not_a_unit'
   that does not correspond with a standard unit or units in the variable's
   parent component or model.
   See section 11.1.1.2 in the CellML specification.</literal_block>
            <paragraph>Variables must have units defined.
                These can be either something from the built-in list within libCellML (which you can read in the specifications document), or something you define yourself.
                We’ll look at user defined units in <reference internal="True" refuri="../tutorial3/tutorial3_py#tutorial3-py"><inline classes="std std-ref">Tutorial 3</inline></reference>, but for now it’s enough to see that the
                units which are associated with variable <literal classes="code">b</literal> are not valid.
                We’ll change it to be <literal classes="code">"dimensionless"</literal> instead.</paragraph>
            <container classes="nb">
                <paragraph><strong>Remember</strong> that items can be accessed through their name (as below) or their index (as above).</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Access the variable named "b" inside the "i_am_a_component" component
# and set its units to be "dimensionless".
your_model_here.component("i_am_a_component").variable("b").setUnits("dimensionless")</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> Add the fix for this error and check that it’s worked by running your code.</paragraph>
            </container>
            <transition></transition>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">Validator error[3]:
   Description: Variable 'c' has an invalid initial value
   'this_variable_doesnt_exist'. Initial values must be a real number
   string or a variable reference.
   See section 11.1.2.2 in the CellML specification.</literal_block>
            <paragraph>We can either access members by their index or their name, as shown above, or we can create a pointer to them instead (as below).
                Initial values (if set) must be a valid variable name in the same component, or a real number.</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Retrieve a pointer for the problem variable with a combo of names and index.
variableC = your_model_here.component(0).variable("c")

# Fix the initial value of the variable.  Note that this could also be a
# variable name in the same component.
variableC.setInitialValue(20.0)</literal_block>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Add the fix for this error and check that it’s worked by running your code.</paragraph>
            </container>
            <transition></transition>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">Validator error[4]:
   Description: CellML identifiers must contain one or more basic Latin
   :term:`alphabetic&lt;Basic Latin alphabetic character&gt;` characters.
   See section 3.1.3 in the CellML specification.
Validator error[5]:
   Description: Variable 'd' does not have a valid units attribute.
   See section 11.1.1.2 in the CellML specification.</literal_block>
            <paragraph>These two errors go together too.
                Because we haven’t defined a <literal classes="code">units</literal> attribute for variable <literal classes="code">d</literal>, it effectively has a blank name, which is not
                allowed.
                Simply assigning units to the variable will fix both errors.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.d</strong> You already know how to add units to a variable (as in step 3.a) so go ahead and fix this error any way you see fit.</paragraph>
            </container>
            <transition></transition>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">Description: MathML ci element has the child text 'a' which does not
    correspond with any variable names present in component
    'i_am_a_component' and is not a variable defined within a bvar element.</literal_block>
            <paragraph>The maths block is complaining that it is being asked to compute <math>a = b + c</math> but in the component there is no variable called <literal classes="code">"a"</literal>.
                Since we corrected - or tried to - this earlier by naming the first variable in the component <literal classes="code">"A"</literal>, you need to go back and change it to lower-case instead.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.e</strong> Fix up this last error, and check for yourself that your corrected model is now error-free.</paragraph>
            </container>
        </section>
        <section ids="step-4-have-a-look-at-the-corrected-model" names="step\ 4:\ have\ a\ look\ at\ the\ corrected\ model">
            <title refid="id5">Step 4: Have a look at the corrected model</title>
            <paragraph>Let’s have a look at our corrected model by calling that same utility function which we used earlier to print it to the screen.
                You should see something like this:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">The model name is: 'tutorial_2_model'
The model id is: 'tutorial 2 id has spaces'
The model defines 0 custom units:
The model has 1 components:
    Component[0] has name: 'i_am_a_component'
    Component[0] has id: 'my_component_id'
    Component[0] has 4 variables:
        Variable[0] has name: 'a'
        Variable[0] has units: 'dimensionless'
        Variable[1] has name: 'b'
        Variable[1] has units: 'dimensionless'
        Variable[2] has name: 'c'
        Variable[2] has initial_value: '20'
        Variable[2] has units: 'dimensionless'
        Variable[3] has name: 'd'
        Variable[3] has units: 'dimensionless'</literal_block>
        </section>
        <section ids="step-5-serialise-and-output-the-model-to-a-file" names="step\ 5:\ serialise\ and\ output\ the\ model\ to\ a\ file">
            <title refid="id6">Step 5: Serialise and output the model to a file</title>
            <container classes="dothis">
                <paragraph><strong>5.a</strong> Just as you did in <reference internal="True" refuri="../tutorial1/tutorial1_py#tutorial1-py"><inline classes="std std-ref">Tutorial 1</inline></reference>, create a <literal classes="code">Printer</literal> and use it to serialise your model to a string.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.b</strong> Finally, write your model string to a <literal classes="code">*.cellml</literal> file.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.c</strong> Go and have a cuppa, you’re done!</paragraph>
            </container>
        </section>
    </section>
</document>
