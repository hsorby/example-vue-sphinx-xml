<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="/Users/hsor001/Projects/Webstorm/test-sphinx/docs/tutorials/tutorial4/tutorial4_cpp.rst">
    <target refid="tutorial4-cpp"></target>
    <section ids="tutorial-4-c-generating-code-and-model-simulation tutorial4-cpp" names="tutorial\ 4\ c++:\ generating\ code\ and\ model\ simulation tutorial4_cpp">
        <title>Tutorial 4 C++: Generating code and model simulation</title>
        <paragraph>This tutorial assumes that you are comfortable with:</paragraph>
        <block_quote>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Interacting with a model and its entities using the API (see <reference internal="True" refuri="../tutorial3/tutorial3_cpp#tutorial3-cpp"><inline classes="std std-ref">Tutorial 3</inline></reference>); and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Using the <literal classes="code">Generator</literal> functionality to output files in C or Python (see <reference internal="True" refuri="../tutorial3/tutorial3_cpp#tutorial3-cpp"><inline classes="std std-ref">Tutorial 3</inline></reference>).</paragraph>
                </list_item>
            </bullet_list>
        </block_quote>
        <paragraph>By the end of this tutorial you will be able to:</paragraph>
        <block_quote>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Interact with files created by the <literal classes="code">Generator</literal> to retrieve information for integrating; and</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use the simple solver provided to numerically integrate the governing equations of the model.</paragraph>
                </list_item>
            </bullet_list>
        </block_quote>
        <topic classes="contents local" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id5" refid="step-1-include-the-generated-code-in-this-project">Step 1: Include the generated code in this project</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id6" refid="step-2-investigate-the-information-items-in-the-generated-files">Step 2: Investigate the information items in the generated files</reference></paragraph>
                    <bullet_list>
                        <list_item>
                            <paragraph><reference ids="id7" refid="classification-of-variables">Classification of variables</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id8" refid="step-3-investigate-the-functions-provided-in-the-generated-files">Step 3: Investigate the functions provided in the generated files</reference></paragraph>
                    <bullet_list>
                        <list_item>
                            <paragraph><reference ids="id9" refid="allocating-arrays">Allocating arrays</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id10" refid="defining-the-initial-values">Defining the initial values</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id11" refid="step-4-iterate-through-the-solution">Step 4: Iterate through the solution</reference></paragraph>
                    <bullet_list>
                        <list_item>
                            <paragraph><reference ids="id12" refid="specification-of-the-variables">Specification of the variables</reference></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id13" refid="specification-of-states-and-rates">Specification of states and rates</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id14" refid="step-5-output">Step 5: Output</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="step-1-include-the-generated-code-in-this-project" names="step\ 1:\ include\ the\ generated\ code\ in\ this\ project">
            <title refid="id5">Step 1: Include the generated code in this project</title>
            <paragraph>In <reference internal="True" refuri="../tutorial3/tutorial3_cpp#tutorial3-cpp"><inline classes="std std-ref">Tutorial 3</inline></reference> you created a CellML model representing the population dynamics in a predator-prey situation, and used the <literal classes="code">Generator</literal> to write files which can be run using a numerical integration solver in either Python or C.</paragraph>
            <paragraph>This tutorial is slightly different from the other ones because you will need to change the way your project is compiled and built in order to include the generated code.
                As before, if you didn’t complete the earlier tutorial in which the generated code was created, you can use files from the
                <literal classes="code">resources</literal> folder instead.</paragraph>
            <paragraph>Because this is for generated code in C you will need the files:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="f87770529ec1aaa42691dbcaa2421c72/tutorial3_PredatorPrey_generated.cpp" refdoc="tutorials/tutorial4/tutorial4_cpp" refdomain="" refexplicit="False" reftarget="../resources/tutorial3_PredatorPrey_generated.cpp" reftype="download" refwarn="False"><literal classes="xref download">../resources/tutorial3_PredatorPrey_generated.cpp</literal></download_reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="70027e17c17ddb85f2a92b70165ebb68/tutorial3_PredatorPrey_generated.h" refdoc="tutorials/tutorial4/tutorial4_cpp" refdomain="" refexplicit="False" reftarget="../resources/tutorial3_PredatorPrey_generated.h" reftype="download" refwarn="False"><literal classes="xref download">../resources/tutorial3_PredatorPrey_generated.h</literal></download_reference></paragraph>
                </list_item>
            </bullet_list>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> Enter the path to the generated header/interface <literal classes="code">.h</literal> file in the <literal classes="code">#include</literal> section at the top of your <literal classes="code">tutorial4.cpp</literal> file.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> If you’re using the generated file with a <literal classes="code">.c</literal> extension you will need to change the file extension to <literal classes="code">.cpp</literal> for it to build correctly with the supplied template.
                    Do this now.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.c</strong> Add the name and path of the implementation <literal classes="code">.cpp</literal> file into the CMakeLists.txt file so that it’s built with your project.</paragraph>
                <paragraph>Inside the CMakeLists.txt file:
                    .. code-block:: cmake</paragraph>
                <block_quote>
                    <paragraph>#   1.b, c Note that you will need to adjust the file name here to match the one that you generated
                        #          in Tutorial 3.  You will also need to change its extension to be <problematic ids="id2" refid="id1">*</problematic>.cpp instead of <problematic ids="id4" refid="id3">*</problematic>.c in
                        #          order for CMake to accept it.
                        set (PROJECT_SRC</paragraph>
                    <block_quote>
                        <block_quote>
                            <paragraph>${PROJECT_NAME}.cpp
                                ../utilities/tutorial_utilities.cpp
                                ../resources/tutorial3_PredatorPrey_generated.cpp</paragraph>
                        </block_quote>
                        <paragraph>)</paragraph>
                    </block_quote>
                </block_quote>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.d</strong> Open your generated <literal classes="code">.cpp</literal> file and change the name of the header it includes using the <literal classes="code">#include</literal> statement to be the name of your generated header <literal classes="code">.h</literal> file.
                    By default this is <literal classes="code">#include "model.h"</literal>.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.e</strong> The version which the generated code was created with is stored in a variable called <literal classes="code">LIBCELLML_VERSION</literal>.
                    Print this to the terminal and check that it matches the version of libCellML library which you’re using, just like in <reference internal="True" refuri="../tutorial0/tutorial0_cpp#tutorial0-cpp"><inline classes="std std-ref">Tutorial 0</inline></reference>.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.f</strong> Call <literal classes="code">cmake</literal> to generate the makefile, <literal classes="code">make</literal> to build the executable, and run the code so far to check that the versions match.</paragraph>
                <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">cmake -DINSTALL_PREFIX=../../install .
make -j
./tutorial4</literal_block>
            </container>
        </section>
        <section ids="step-2-investigate-the-information-items-in-the-generated-files" names="step\ 2:\ investigate\ the\ information\ items\ in\ the\ generated\ files">
            <title refid="id6">Step 2: Investigate the information items in the generated files</title>
            <paragraph>This step is about figuring out what’s contained in the generated files, and demonstrating how you can use them to run your simulation.</paragraph>
            <paragraph>The implementation code contains some constants as well as functions which make it simple to switch between models for solution.
                This tutorial will pretend that you know nothing about the contents of the CellML model from which the files were generated, and take you through writing a general numerical solver.</paragraph>
            <section ids="classification-of-variables" names="classification\ of\ variables">
                <title refid="id7">Classification of variables</title>
                <paragraph>The <literal classes="code">Generator</literal> classifies all the <literal classes="code">Variable</literal> items within each <literal classes="code">Component</literal> as:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><strong>Variables</strong>: These do not require integration, but come in three types:</paragraph>
                            <bullet_list bullet="-">
                                <list_item>
                                    <paragraph><literal classes="code">CONSTANT</literal> variables do not need any kind of calculation;</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><literal classes="code">COMPUTED_CONSTANT</literal> variables need calculation but not integration; and</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><literal classes="code">ALGEBRAIC</literal> variables need …?? <strong>TODO</strong></paragraph>
                                </list_item>
                            </bullet_list>
                        </list_item>
                        <list_item>
                            <paragraph><strong>Variables of integration</strong>: Also called “base variables”, “free variables”, or “VOI”, these are specified by the <literal classes="code">&lt;bvar&gt;</literal> child of the <literal classes="code">&lt;diff&gt;</literal> operator.
                                VOI must not be initialised.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><strong>States</strong>: These are those variables which need integration by a solver.
                                They are the <literal classes="code">&lt;ci&gt;</literal> child of the <literal classes="code">&lt;diff&gt;</literal> operator.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <paragraph>We can see this results of this classification process in the generated code returned by a call to the <literal classes="code">implementationCode</literal> function of the <literal classes="code">Generator</literal>.</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Define the VOI variable of integration, its units and the name of its parent component.
const VariableInfo VOI_INFO = {"time", "dimensionless", "shark_fish_interaction"};

// Define the states: the variables which require integration.
const VariableInfo STATE_INFO[] = {
    {"y_f", "dimensionless", "shark_fish_interaction"},
    {"y_s", "dimensionless", "shark_fish_interaction"}
};

// Define the CONSTANT and COMPUTED_CONSTANT variables: these do not require integration.
const VariableInfoWithType VARIABLE_INFO[] = {
    {"a", "dimensionless", "shark_fish_interaction", CONSTANT},
    {"b", "dimensionless", "shark_fish_interaction", CONSTANT},
    {"c", "dimensionless", "shark_fish_interaction", CONSTANT},
    {"d", "dimensionless", "shark_fish_interaction", COMPUTED_CONSTANT}
};</literal_block>
                <paragraph>These are accessible in the generated code:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal classes="code">VARIABLE_COUNT</literal> is an integer representing the number of variables (including constants) in the model.
                                Note that these are variables which might need calculation, but do not need integration.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">VARIABLE_INFO</literal> is an array of <literal classes="code">VariableInfoWithType</literal> structs, which contains:</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>a <literal classes="code">name</literal> field;</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>a <literal classes="code">units</literal> field;</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>a <literal classes="code">component</literal> field; and</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>a <literal classes="code">type</literal> enum field.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                        <list_item>
                            <paragraph>the <literal classes="code">VARIABLE_INFO</literal> array is <literal classes="code">VARIABLE_COUNT</literal> long.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <container classes="dothis">
                    <paragraph><strong>2.a</strong> Retrieve the number of variables from the generated code, and print the information related to each of them to the terminal.</paragraph>
                </container>
                <paragraph>There are similar information items related to the state variables.
                    These are:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal classes="code">STATE_COUNT</literal> is an integer representing the number of state variables in the model.
                                These are the variables which need to be integrated.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">STATE_INFO</literal> is an array of <literal classes="code">VariableInfo</literal>
                                structs, which contains:</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>a <literal classes="code">name</literal> field</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>a <literal classes="code">units</literal> field</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>a <literal classes="code">component</literal> field</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                        <list_item>
                            <paragraph>the <literal classes="code">STATE_INFO</literal> array is <literal classes="code">STATE_COUNT</literal> long.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <container classes="dothis">
                    <paragraph><strong>2.b</strong> Retrieve the number of state variables from the generated code, and print the information related to each of them to the terminal.</paragraph>
                </container>
                <paragraph>The final information stored is the name and attributes of the base integration variable (variable of integration, VOI).
                    This is stored in <literal classes="code">VOI_INFO</literal>, a <literal classes="code">VariableInfo</literal> item.</paragraph>
                <container classes="dothis">
                    <paragraph><strong>2.c</strong> Retrieve the information about the VOI and print it to the terminal.</paragraph>
                </container>
            </section>
        </section>
        <section ids="step-3-investigate-the-functions-provided-in-the-generated-files" names="step\ 3:\ investigate\ the\ functions\ provided\ in\ the\ generated\ files">
            <title refid="id8">Step 3: Investigate the functions provided in the generated files</title>
            <paragraph>As well as the information items, the generated code also contains functions which are derived from the governing equations in the MathML blocks in the original CellML model.</paragraph>
            <paragraph>In order to perform any kind of numerical integration, a solver needs three things:</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>An array of the current values of all state variables (length = <literal classes="code">STATE_COUNT</literal>);</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A way to update the gradient function of each of the state variables as the solution progresses; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A method to move from the current solution position to the next one.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph>For a more detailed background on numerical integration, please see <reference internal="True" refuri="../../theory/theory_ode_solutions#theory-ode-solutions"><inline classes="std std-ref">Solution methods for ODEs</inline></reference>.</paragraph>
            <section ids="allocating-arrays" names="allocating\ arrays">
                <title refid="id9">Allocating arrays</title>
                <paragraph>Because we’re writing this tutorial based around a general situation, we can use the helper functions provided to allocate these arrays to the right size.
                    These are:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal classes="code">createStatesArray</literal> will allocate an array of length <literal classes="code">STATE_COUNT</literal> and element type <literal classes="code">double</literal> (which can be used to allocate the array of rates too); and</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">createVariableArray</literal> will allocate an array of length <literal classes="code">VARIABLE_COUNT</literal> and element type <literal classes="code">double</literal>.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <container classes="dothis">
                    <paragraph><strong>3.a</strong> Allocate three arrays: one for the state variables, one for the rates, and one for the variables.</paragraph>
                </container>
            </section>
            <section ids="defining-the-initial-values" names="defining\ the\ initial\ values">
                <title refid="id10">Defining the initial values</title>
                <paragraph>After allocating these arrays, we need to fill them with the information.
                    In <reference internal="True" refuri="../tutorial3/tutorial3_cpp#tutorial3-cpp"><inline classes="std std-ref">Tutorial 3</inline></reference> we used three equations to define this model:</paragraph>
                <math_block docname="tutorials/tutorial4/tutorial4_cpp" label="True" nowrap="False" number="True" xml:space="preserve">\frac{dy_s}{dt} =f(sharks, fishes, time) = a y_s + b y_s y_f

\frac{dy_f}{dt} =f(sharks, fishes, time) = c y_f + d y_s y_f

c = a - 2.0</math_block>
                <paragraph>with constants <math>(a, b, d)=(1.2, -0.6, 0.3)</math> and initial condtions of <math>y_s(t=0)=2.0</math> and <math>y_f(t=0)=1.0</math>.</paragraph>
                <paragraph>If you look inside the implementation file (<literal classes="code">*.c/cpp</literal>) which was generated in the last tutorial you’ll see the code shown below, and recognise its correlation with the initial conditions above.</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// tutorial3_PredatorPrey_generated.cpp:
void initializeStatesAndConstants(double *states, double *variables)
{
    states[0] = 2.0;        // represents the inital number of sharks
    states[1] = 1.0;        // represents the inital number of fish (in thousands)
    variables[0] = 1.2;     // a, constant in the rates equation for sharks
    variables[1] = -0.6;    // b, constant in the rates equation for sharks
    variables[2] = 0.3;     // d, constant in the rates equation for fish
}</literal_block>
                <container classes="dothis">
                    <paragraph><strong>3.b</strong> Call the <literal classes="code">initializeStatesAndConstants</literal> function to initalise the arrays you created earlier.
                        Print them to the terminal for checking. <strong>TODO</strong> US spelling of functions??</paragraph>
                </container>
                <paragraph>Printing to the terminal should show you that while the CellML <literal classes="code">Variable</literal> items for which we specified an initial value have been applied, the constant <literal classes="code">c</literal> has not yet been evaluated.
                    There’s a second helper function <literal classes="code">computeComputedConstants(double *variables)</literal> which will do this for you.</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// tutorial3_PredatorPrey_generated.cpp:
void computeComputedConstants(double *variables)
{
    variables[3] = variables[0] - 2.0;    // c, constant in the rates equation for fish
}</literal_block>
                <container classes="dothis">
                    <paragraph><strong>3.c</strong> Call the <literal classes="code">computeComputedConstants</literal> function, and reprint the variables array to the terminal to check that the initial values for all variables have now been set correctly.</paragraph>
                </container>
                <paragraph>Now we’re ready to begin solving the model.</paragraph>
            </section>
        </section>
        <section ids="step-4-iterate-through-the-solution" names="step\ 4:\ iterate\ through\ the\ solution">
            <title refid="id11">Step 4: Iterate through the solution</title>
            <paragraph>A simple solver has been provided for you already, as outlined in <inline classes="xref std std-ref">&lt;solver&gt;</inline>.
                Please visit that page for details of its operation, or you can easily write your own following the steps below.</paragraph>
            <paragraph>We now make use of a simple routine to step through the solution iterations using the Euler method to update the state variables.
                Following initialisation of some solution controls (time step, end point) there are three general parts to each iteration:</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Computing the variables at the current timestep;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Computing the gradient functions or rates at the current timestep; and</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Updating the state variables using an Euler* step.
                            * Note that this could be any stepping method - we just use this one as it’s very simple.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Define some variables to control the total number of steps to take, and the size that those steps should be.
                    In this example it’s safe to use a step of 0.001 and an end time of 20.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.b</strong> Create a file for output and open it.
                    We’ll simply write the solution directly to the file instead of allocating memory for storage.
                    Name your columns with VOI and the state variable names and units.</paragraph>
            </container>
            <section ids="specification-of-the-variables" names="specification\ of\ the\ variables">
                <title refid="id12">Specification of the variables</title>
                <paragraph>In each iteration the variables may need to be updated.
                    In our example we do not have any dependencies (that is, <math>a, b, c, d</math> are constants) so the function which updates them is blank here; this is not true of the general case.</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// tutorial3_PredatorPrey_generated.cpp:
void computeVariables(double voi, double *states, double *rates, double *variables)
{
}</literal_block>
            </section>
            <section ids="specification-of-states-and-rates" names="specification\ of\ states\ and\ rates">
                <title refid="id13">Specification of states and rates</title>
                <paragraph>Once a <literal classes="code">Variable</literal> has been identified as a <emphasis>state</emphasis> variable, it is paired by the <literal classes="code">Generator</literal> to its corresponding entry in the <literal classes="code">rates</literal> array, which represents its gradient function.</paragraph>
                <paragraph>Because the gradients of each of the <literal classes="code">states</literal> could include dependency on time or any variable value, the gradients must be updated throughout the solution process.
                    This is done by calling the <literal classes="code">computeRates</literal> function to recalculate the rate for each state variable.</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void computeRates(double voi, double *states, double *rates, double *variables)
{
    // The "rates" array contains the gradient function for each of the variables
    // which is being integrated (the "states")

    // This equation is the equivalent of d(sharks)/dt = a*y_sharks + b*y_sharks*y_fishes
    rates[0] = variables[0]*states[0] + variables[1]*states[0]*states[1];

    // This equation is the equivalent of d(fishes)/dt = c*y_fishes + d*y_sharks*y_fishes
    rates[1] = variables[3]*states[1] + variables[2]*states[0]*states[1];
}</literal_block>
                <paragraph><strong>TODO</strong> Check which order to call these in? rates or variables first?</paragraph>
                <container classes="dothis">
                    <paragraph><strong>4.c</strong> Iterate through the time interval <math>[0, 20]</math> and update the state variables using the Euler update method: <literal classes="code">x[n+1] = x[n] + r[n]*stepSize</literal>.
                        At each step you will need to:</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Recompute the variables, <literal classes="code">y</literal>;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Recompute the rates, <literal classes="code">r</literal>;</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Compute the state variables <literal classes="code">x</literal>, using the update method above; and</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Write the output to a file.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </container>
            </section>
        </section>
        <section ids="step-5-output" names="step\ 5:\ output">
            <title refid="id14">Step 5: Output</title>
            <container classes="dothis">
                <paragraph><strong>5.a</strong> Now it’s time for housekeeping.
                    Use the <literal classes="code">deleteArray</literal> function to free the three arrays you allocated in step 3.a.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.b</strong> You can retrieve your solution from the file you’ve written for plotting in your program of choice.
                    If all has gone well you should see something similar to that shown in <literal classes="xref std std-numref">sharks_and_fish</literal> below.</paragraph>
            </container>
            <figure align="center" ids="sharks-and-fish" names="sharks_and_fish">
                <image alt="Euler solution to the predator-prey model" candidates="{'*': 'tutorials/tutorial4/../images/sharks_and_fish.png'}" uri="tutorials/tutorial4/../images/sharks_and_fish.png"></image>
                <caption>Euler solution to the predator-prey population model</caption>
            </figure>
            <container classes="dothis">
                <paragraph><strong>5.c</strong> Go and have a cuppa, you’re done!</paragraph>
            </container>
        </section>
    </section>
</document>
