<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="/Users/hsor001/Projects/Webstorm/test-sphinx/docs/tutorials/quickstart/quickstart.rst">
    <target refid="quickstart"></target>
    <section ids="quickstart-and-common-examples quickstart" names="quickstart\ and\ common\ examples quickstart">
        <title refid="id1">Quickstart and common examples</title>
        <paragraph>If you’re reading this it’s presumed that you’re already familiar with the structure and usage of CellML models, and you want to get started on creating or reading your own as soon as possible.
            If that doesn’t sound like you, and you’d rather start with a gentler introduction, please start from <reference internal="True" refuri="../tutorial0/outline0#tutorial0"><inline classes="std std-ref">Tutorial 0</inline></reference> instead.</paragraph>
        <paragraph><strong>TODO</strong> instalation guide to go here once processes are finalised.</paragraph>
        <paragraph>This section explains the basic classes inside libCellML, and the most commonly used functionality associated with them.</paragraph>
        <topic classes="contents" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="quickstart-and-common-examples">Quickstart and common examples</reference></paragraph>
                    <bullet_list>
                        <list_item>
                            <paragraph><reference ids="id2" refid="general-api-strategy-for-use">General API strategy for use</reference></paragraph>
                            <bullet_list>
                                <list_item>
                                    <paragraph><reference ids="id3" refid="include-the-libcellml-library-in-your-project">Include the libCellML library in your project</reference></paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><reference ids="id4" refid="parse-an-existing-model-from-a-file">Parse an existing <literal>Model</literal> from a file</reference></paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><reference ids="id5" refid="debug-and-validate-a-model">Debug and validate a Model</reference></paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><reference ids="id6" refid="serialise-a-model-into-cellml2-for-printing-to-a-file">Serialise a <literal>Model</literal> into CellML2 for printing to a file</reference></paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><reference ids="id7" refid="generate-a-c-or-python-version-of-a-cellml2-model">Generate a C or Python version of a CellML2 model</reference></paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><reference ids="id8" refid="convert-a-cellml1-1-model-to-cellml2-0">Convert a CellML1.1 model to CellML2.0</reference></paragraph>
                                </list_item>
                            </bullet_list>
                        </list_item>
                        <list_item>
                            <paragraph><reference ids="id9" refid="functionality-associated-with-each-class">Functionality associated with each class</reference></paragraph>
                            <bullet_list>
                                <list_item>
                                    <paragraph><reference ids="id10" refid="using-the-model-class">Using the <literal>Model</literal> class</reference></paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><reference ids="id11" refid="using-the-component-class">Using the <literal>Component</literal> class</reference></paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><reference ids="id12" refid="create-and-naming-items-model-component-variable-units">Create and naming items: <literal>Model</literal>, <literal>Component</literal>, <literal>Variable</literal>, <literal>Units</literal></reference></paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph><reference ids="id13" refid="retrieving-named-items-model-component-variable-units">Retrieving named items: <literal>Model</literal>, <literal>Component</literal>, <literal>Variable</literal>, <literal>Units</literal></reference></paragraph>
                                </list_item>
                            </bullet_list>
                        </list_item>
                    </bullet_list>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="general-api-strategy-for-use" names="general\ api\ strategy\ for\ use">
            <title refid="id2">General API strategy for use</title>
            <paragraph>The tutorials here have taken a top-down approach to model creation. They start by creating components which define mathematical behaviour.
                The <literal classes="code">Validator</literal> is then called to list the variables and units which the mathematics requires.
                This process is repeated until all the components needed have been created or imported, and the combined model is ready for output.
                Model output takes one of two forms - either serialisation by writing to a CellML2.0 file using the Printer functionality, or code generation into C or Python using the Generator functionality.
                Of course you are welcome to use the API in a top-down or bottom-up manner as you see fit.</paragraph>
            <target refid="include-libcellml-library"></target>
            <section ids="include-the-libcellml-library-in-your-project" names="include\ the\ libcellml\ library\ in\ your\ project">
                <title refid="id3">Include the libCellML library in your project</title>
                <paragraph>If you’ve followed <reference internal="True" refuri="../tutorial0/outline0#tutorial0"><inline classes="std std-ref">the instructions for installing libCellML</inline></reference> then the library is available for use as shown below.
                    Note that this doesn’t invoke the libCellML namespace, so classes are accessed using the <literal classes="code">libcellml::</literal> prefix.</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// main.cpp
#include &lt;libcellml&gt;

auto model = libcellml::Model::create();</literal_block>
                <paragraph>In Python classes can be imported individually as required, or the whole library imported at once.</paragraph>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># main.py
import libcellml                       # import the entire library, or
from libcellml import Model, Variable  # import specific classes as needed</literal_block>
            </section>
            <section ids="parse-an-existing-model-from-a-file" names="parse\ an\ existing\ model\ from\ a\ file">
                <title refid="id4">Parse an existing <literal>Model</literal> from a file</title>
                <paragraph>The following code will read a file called <literal classes="code">quickstart.cellml</literal> and deserialise its contents into a <literal classes="code">ModelPtr</literal> instance:</paragraph>
                <paragraph>In C++:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">std::ifstream inFile("../resources/quickstart.cellml");
std::stringstream inFileContents;
inFileContents &lt;&lt; inFile.rdbuf();

// Creating a Parser instance
auto parser = libcellml::Parser::create();

// Deserialising the CellML contents of the parsed file into a Model pointer
libcellml::ModelPtr model = parser-&gt;parseModel(inFileContents.str());

// Checking the Parser for errors
for(size_t e = 0; e &lt; parser-&gt;errorCount(); ++e) {
  std::cout&lt;&lt;parser-&gt;error(e)-&gt;description()&lt;&lt;std::endl;
  std::cout&lt;&lt;parser-&gt;error(e)-&gt;referenceHeading()&lt;&lt;std::endl;
}</literal_block>
                <paragraph>In Python:</paragraph>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">from libcellml import Parser

#  Open the CellML file for reading
read_file = open("../resources/quickstart.cellml", "r")

#  Create a libCellML Parser, and use it to parse the file string contents
#  and convert it into a CellML Model structure
parser = Parser()
model = parser.parseModel(read_file.read())

# Check the parser for errors
for e in range(0, parser.errorCount()):
    print(parser.error(e).description())
    print(parser.error(e).referenceHeading())</literal_block>
            </section>
            <section ids="debug-and-validate-a-model" names="debug\ and\ validate\ a\ model">
                <title refid="id5">Debug and validate a Model</title>
                <paragraph>The <literal classes="code">Validator</literal> class is used to check your final model for errors before export or code generation, but it can also be used as a debugger during the process of your model creation or editing.
                    The error descriptions should give enough information to allow you to find and fix the problem, and the specification heading refers to the section within the <inline classes="xref std std-ref">formal CellML2.0 description</inline> which is affected by the error.</paragraph>
                <paragraph>In C++:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Create a Validator instance and pass the model to it for checking
libcellml::ValidatorPtr validator = libcellml::Validator::create();
validator-&gt;validateModel(model);

// Retrieve the errors from the validator and print their specificiation
// reference and description
for (size_t e = 0; e &lt; validator-&gt;errorCount(); ++e) {
    libcellml::IssuePtr error = validator-&gt;error(e);
    std::cout &lt;&lt; error-&gt;description() &lt;&lt; std::endl;
    std::cout &lt;&lt; error-&gt;specificationReference() &lt;&lt; std::endl
              &lt;&lt; std::endl;
}</literal_block>
                <paragraph>In Python:</paragraph>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">from libcellml import Validator

# Create a Validator instance and pass it the model for checking
validator = Validator()
validator.validateModel(model)

# Check the validator for errors
for e in range(0, validator.errorCount()):
    print(validator.error(e).description())
    print(validator.error(e).referenceHeading())</literal_block>
            </section>
            <section ids="serialise-a-model-into-cellml2-for-printing-to-a-file" names="serialise\ a\ model\ into\ cellml2\ for\ printing\ to\ a\ file">
                <title refid="id6">Serialise a <literal>Model</literal> into CellML2 for printing to a file</title>
                <paragraph>The <literal classes="code">Printer</literal> class has the opposite functionality to the <literal classes="code">Parser</literal> class.
                    It accepts an existing <literal classes="code">ModelPtr</literal> and creates a <literal classes="code">string</literal> which can be written to a file.
                    As with the <literal classes="code">Parser</literal> and the <literal classes="code">Validator</literal>, the <literal classes="code">Printer</literal> also records errors which can be accessed as above.</paragraph>
                <paragraph>In C++:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Create a Printer instance and pass the model into it
libcellml::PrinterPtr printer = libcellml::Printer::create();

// The output of the printModel function is a string representing the serialised model
std::string serialisedModelString = printer-&gt;printModel(model);

// Check the printer for errors
for (size_t e = 0; e &lt; printer-&gt;errorCount(); ++e) {
    libcellml::IssuePtr error = printer-&gt;error(e);
    std::cout &lt;&lt; error-&gt;description() &lt;&lt; std::endl;
    std::cout &lt;&lt; error-&gt;specificationReference() &lt;&lt; std::endl
              &lt;&lt; std::endl;
}

// Write the serialised string to a file
std::string outFileName = "my_printed_file.cellml";
std::ofstream outFile(outFileName);
outFile &lt;&lt; serialisedModelString;
outFile.close();</literal_block>
                <paragraph>In Python:</paragraph>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">from libcellml import Printer

# Create a Printer instance and pass the model into it
printer = Printer()

# The output of the printModel function is a string representing the serialised model
serialised_model = printer.printModel(model)

# Check the printer for errors
for e in range(0, printer.errorCount()):
    print(printer.error(e).description())
    print(printer.error(e).referenceHeading())

# Write the string to a file
write_file = open("my_printed_file.cellml", "w")
write_file.write(serialised_model)
write_file.close()</literal_block>
            </section>
            <section ids="generate-a-c-or-python-version-of-a-cellml2-model" names="generate\ a\ c\ or\ python\ version\ of\ a\ cellml2\ model">
                <title refid="id7">Generate a C or Python version of a CellML2 model</title>
                <paragraph>Once you have a model, and have checked that it is free of validation errors, you can call the <literal classes="code">Generator</literal> instance to create code which represents your model in either C or Python format.
                    For more information on the <title_reference>Generator</title_reference> please see the <inline classes="xref std std-ref">Generator information</inline> pages.</paragraph>
            </section>
            <section ids="convert-a-cellml1-1-model-to-cellml2-0" names="convert\ a\ cellml1.1\ model\ to\ cellml2.0">
                <title refid="id8">Convert a CellML1.1 model to CellML2.0</title>
                <paragraph>libCellML deals exclusively with models which meet the <reference internal="False" refuri="https://cellml-specification.readthedocs.io/en/latest/CellML2.0 specification">CellML2.0 specification</reference>.
                    To use libCellML with a previous version (1.0, 1.1) you will need to first translate it into CellML2 using the <reference internal="False" refuri="https://github.com/hsorby/cellml1to2">cellML1to2</reference> tool.</paragraph>
                <paragraph><strong>TODO</strong> Needs more instructions for how to use this and perhaps move to main repo?</paragraph>
            </section>
        </section>
        <section ids="functionality-associated-with-each-class" names="functionality\ associated\ with\ each\ class">
            <title refid="id9">Functionality associated with each class</title>
            <section ids="using-the-model-class" names="using\ the\ model\ class">
                <title refid="id10">Using the <literal>Model</literal> class</title>
                <paragraph>In C++:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Create a new named model
auto model = libcellml::Model::create("my_model");
// Retrieve the name
std::string modelName = model-&gt;name();

// Add a component
model-&gt;addComponent(component);
// Count the direct child components
int numComponents = model-&gt;componentCount();
// Retrieve a component by index
indexedComponent = model-&gt;component(0);
// Retrieve a component by name
namedComponent = model-&gt;component("my_component");

// Add units
model-&gt;addUnits(units);
// Retrieve the number of units
int numUnits = model-&gt;unitsCount();
// Retrieve units by index
indexedUnits = model-&gt;units(0);
// Retrieve units by name
namedUnits = model-&gt;units("my_units");</literal_block>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Create a new model
auto model = Model.create()
# Set the name
model.setName("my_model")
# Retrieve the name
modelName = model.name()

# Add a component
model.addComponent(component)
# Count the direct child components
numComponents = model.componentCount()
# Retrieve a component by index
indexedComponent = model.component(0)
# Retrieve a component by name
namedComponent = model.component("my_component")

# Add units
model.addUnits(units)
# Retrieve the number of units
numUnits = model.unitsCount()
# Retrieve units by index
indexedUnits = model.units(0)
# Retrieve units by name
namedUnits = model.units("my_units")</literal_block>
            </section>
            <section ids="using-the-component-class" names="using\ the\ component\ class">
                <title refid="id11">Using the <literal>Component</literal> class</title>
                <paragraph>Components are the building blocks of the CellML modelling process.
                    They are a modular representation of anything which is to be simulated, including the governing equations and their variables, and the relationship of this component to any of the others in the model.</paragraph>
                <paragraph>Because components are named items, their basic use follows the same format as for other types of named items.</paragraph>
                <paragraph>In C++</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Add a component to a model
model-&gt;addComponent(component);
// Add a child component to its parent
parentComponent-&gt;addComponent(encapsulatedChildComponent);
// Remove a child component: The childComponent now has a null parent() pointer
parentComponent-&gt;removeComponent(childComponent);
// Remove all child components
parentComponent-&gt;removeAllComponents();

// Count the child components
int numberOfChildComponents = parentComponent-&gt;componentCount();
// Access a child component by index (this returns a pointer to the second child)
childComponent = parentComponent-&gt;component(1);
// Access a child component by name
childComponent = parentComponent-&gt;component("my_child");</literal_block>
                <paragraph><strong>TODO</strong> Not sure if this is the best strategy for documentation??</paragraph>
            </section>
            <section ids="create-and-naming-items-model-component-variable-units" names="create\ and\ naming\ items:\ model,\ component,\ variable,\ units">
                <title refid="id12">Create and naming items: <literal>Model</literal>, <literal>Component</literal>, <literal>Variable</literal>, <literal>Units</literal></title>
                <paragraph>The same idiom applies to all named items: these being <literal classes="code">Model</literal>, <literal classes="code">Component</literal>, <literal classes="code">Variable</literal>, and <literal classes="code">Units</literal> items.
                    For convenience, some constructors are overloaded with attributes which they’ll need anyway.</paragraph>
                <paragraph>In C++:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Create items using the overloaded constructor to specify a name.
auto m1 = libcellml::Model::create("my_model");
auto c1 = libcellml::Component::create("my_component");
auto v1 = libcellml::Variable::create("my_variable");
auto u1 = libcellml::Units::create("my_units");

// Create un-named items and use the setName() function to name them.
auto m2 = libcellml::Model::create();
m2-&gt;setName("my_model");

auto c1 = libcellml::Component::create();
c1-&gt;setName("my_component");

auto v1 = libcellml::Variable::create();
v1-&gt;setName("my_variable");

auto u1 = libcellml::Units::create();
u1-&gt;setName("my_units");</literal_block>
            </section>
            <section ids="retrieving-named-items-model-component-variable-units" names="retrieving\ named\ items:\ model,\ component,\ variable,\ units">
                <title refid="id13">Retrieving named items: <literal>Model</literal>, <literal>Component</literal>, <literal>Variable</literal>, <literal>Units</literal></title>
                <paragraph><strong>TODO</strong></paragraph>
            </section>
        </section>
    </section>
</document>
