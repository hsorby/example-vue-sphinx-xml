<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="/Users/hsor001/Projects/Webstorm/test-sphinx/docs/tutorials/tutorial5/tutorial5_py.rst">
    <target refid="tutorial5-py"></target>
    <section ids="tutorial-5-python-modelling-a-gated-ion-channel tutorial5-py" names="tutorial\ 5\ python:\ modelling\ a\ gated\ ion\ channel tutorial5_py">
        <title>Tutorial 5 Python: Modelling a gated ion channel</title>
        <paragraph>If you’re reading this it’s presumed that you’re already
            comfortable with the serlialisation, mainipulation, and debugging functionality
            available in the libCellML library.  If not, please see the earlier tutorials
            which introduce these issues:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><reference internal="True" refuri="../tutorial1/tutorial1_py#tutorial1-py"><inline classes="std std-ref">Tutorial 1: Reading, writing, and ‘rithmetic in a CellML file</inline></reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../tutorial2/tutorial2_py#tutorial2-py"><inline classes="std std-ref">Tutorial 2: Debugging, error checking, and validation</inline></reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../tutorial3/tutorial3_py#tutorial3-py"><inline classes="std std-ref">Tutorial 3: Creating a model using the API</inline></reference></paragraph>
            </list_item>
        </bullet_list>
        <paragraph>From this point onwards the tutorials will build on work done in the previous
            ones.  If you need to jump in at some intermediate stage
            you will find all the files created by the earlier tutorials in the
            <literal classes="code">resources</literal> folder.</paragraph>
        <topic classes="contents local" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id7" refid="overview">Overview</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id8" refid="create-the-model-and-component-items">1: Create the model and component items</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id9" refid="define-the-mathematical-behaviour">2: Define the mathematical behaviour</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id10" refid="define-the-variables-and-their-units">3. Define the variables and their units</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id11" refid="define-the-units-and-add-to-the-model">4. Define the units and add to the model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id12" refid="serialise-and-generate-code">5: Serialise and generate code</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id13" refid="simulate-the-behavior-of-the-gate">6: Simulate the behavior of the gate</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="overview" names="overview">
            <title refid="id7">Overview</title>
            <paragraph>The basic steps for model creation and output are the same as those in
                <reference internal="True" refuri="../tutorial3/tutorial3_py#tutorial3-py"><inline classes="std std-ref">Tutorial 3</inline></reference>, but here you’ll begin to create a model based on
                the Hodgkin Huxley model. All the biological and mathematical modelling
                background needed for this model are explained in a separate document,
                <reference internal="True" refuri="../../theory/theory_hh#hh-background"><inline classes="std std-ref">Understanding the Hodgkin-Huxley model</inline></reference>.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Create a simple model with one component.  This will represent a gated
                        ion channel, and we’ll write it in such a way that we can reuse it later.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Add mathematics to the component.  This includes writing MathML code as a
                        string and adding it to the component.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Because the maths defined above will need variables, we’ll need to add
                        these to the component as well.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Because the quantities modelled have units, we will define what these are,
                        and make sure that they are included in the model too.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>As always, the steps discussed here are mirrored by the comments in the code
                files attached.  You can choose to either create your own code from the
                structure given in the <literal classes="code">tutorial5.py</literal> file, or to simply read the
                finished code given in the <literal classes="code">tutorial5_complete.py</literal> file.</paragraph>
        </section>
        <section ids="create-the-model-and-component-items" names="1:\ create\ the\ model\ and\ component\ items">
            <title refid="id8">1: Create the model and component items</title>
            <paragraph>Following the same procedures as in previous tutorials, our first step is to
                create new model and component instances.  We haven’t encountered it yet, but
                the real power of modelling comes from our ability to use and reuse different
                items, combining them into more and more complicated situations.  In this case,
                we’re going to create a component which represents a generic gated ion channel;
                it will be reused later on to represent channels for sodium and potassium in
                neuron models, or calcium in a cardiac model.  There’s an introduction to the
                biological and mathematical theory behind this particular model in
                <reference internal="True" refuri="../../theory/theory_hh#hh-background"><inline classes="std std-ref">Understanding the Hodgkin-Huxley model</inline></reference>.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.a</strong>
                    Create a model instance, and name it appropriately.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.b</strong>
                    Create a component, name it, and add the component to the model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.c</strong>
                    Create a validator and use it to verify that your model has no errors.</paragraph>
            </container>
        </section>
        <section ids="define-the-mathematical-behaviour" names="2:\ define\ the\ mathematical\ behaviour">
            <title refid="id9">2: Define the mathematical behaviour</title>
            <paragraph>The next step is to define what the component actually <emphasis>does</emphasis>.  In this case,
                its purpose is to represent a collection of gates in series in order to model
                the channel behaviour.  Let’s start with the simple ODE below:</paragraph>
            <math_block docname="tutorials/tutorial5/tutorial5_py" label="True" nowrap="False" number="True" xml:space="preserve">\frac{dn}{dt} = \alpha_y (1-y) - \beta_y y

</math_block>
            <paragraph>where <math>y</math> is the fraction which is open (so <math>(1-y)</math> must
                be the fraction which is closed), <math>\alpha_y</math> is the opening
                rate, <math>\beta_y</math> is the closing rate, and <math>t</math> is time.</paragraph>
            <paragraph>Now to add this equation into the component we created in Step 1.
                Once the maths is created, the process of adding it is very simple, and follows
                the same pattern as adding anything to anything else: there is a <literal classes="code">setMath</literal>
                command which which does the job nicely.  The more difficult part is creating
                the maths itself.  This was covered in <reference internal="True" refuri="../tutorial3/tutorial3_py#tutorial3-py"><inline classes="std std-ref">Tutorial 3</inline></reference> and there
                are other resources on the <reference internal="False" refuri="https://www.w3.org/TR/MathML2/chapter4.html#id.4.2.1.3">W3 resource pages for MathML2</reference> too.</paragraph>
            <paragraph>Consider the equation above, converted here into MathML2 format:</paragraph>
            <paragraph>Left hand side: <math>\frac{dn}{dt}</math></paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;apply&gt;
    &lt;diff/&gt;
    &lt;bvar&gt;
        &lt;ci&gt;time&lt;/ci&gt;
    &lt;/bvar&gt;
    &lt;ci&gt;y&lt;/ci&gt;
&lt;/apply&gt;</literal_block>
            <paragraph>Right hand side: <math>\alpha_y (1-y) ...</math></paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;apply&gt;
    &lt;minus/&gt;
    &lt;apply&gt;
        &lt;times/&gt;
        &lt;ci&gt;alpha_y&lt;/ci&gt;
        &lt;apply&gt;
            &lt;minus/&gt;
            &lt;cn cellml:units="dimensionless"&gt;1&lt;/cn&gt;
            &lt;ci&gt;y&lt;/ci&gt;
        &lt;/apply&gt;
    &lt;/apply&gt;</literal_block>
            <paragraph><math>... - \beta_y y</math>  <strong>NB</strong> The negative comes from the first <literal classes="code">minus</literal>
                operation in the block above, indicating that the block below subtracted
                from the one above.</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">    &lt;apply&gt;
        &lt;times/&gt;
        &lt;ci&gt;beta_y&lt;/ci&gt;
        &lt;ci&gt;y&lt;/ci&gt;
    &lt;/apply&gt;
&lt;/apply&gt;</literal_block>
            <paragraph>All of this needs to be wrapped inside the <literal classes="code">&lt;math&gt;</literal> tags, which will
                include a namespace definition, as well as the initial <literal classes="code">&lt;apply&gt;</literal> and
                <literal classes="code">&lt;eq/&gt;</literal> tags to assign the left and right-hand sides of the equation:</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;math xmlns="http://www.w3.org/1998/Math/MathML"
        cellml="http://www.cellml.org/cellml/2.0#"&gt;
    &lt;apply&gt;
        &lt;eq/&gt;
            ...
    &lt;/apply&gt;
&lt;/math&gt;</literal_block>
            <container classes="nb">
                <paragraph><strong>Note</strong>:
                    <strong>libCellML will only take MathML2 format</strong>, and <strong>not</strong> the more recent
                    MathML3 or MathML4 formats, which are targetted at presentation rather
                    than content alone.</paragraph>
            </container>
            <paragraph>To proceed with this tutorial you can either write your own MathML string
                simply copy it from the ones defined in the
                <literal classes="code">resources/tutorial5_mathml.py</literal> file.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Create the MathML string(s) representing the following equations:</paragraph>
            </container>
            <math_block docname="tutorials/tutorial5/tutorial5_py" label="True" nowrap="False" number="True" xml:space="preserve">\frac{dn}{dt} = \alpha_y (1-y) - \beta_y y

i_K = g_K . y^{\gamma} . (V-E_K)</math_block>
            <paragraph>… where <math>\alpha_K</math> and <math>\beta_K</math> are the rate constants for the
                opening and closing of the gate, <math>g_K</math> is the open channel conductance,
                <math>y</math> is the fraction of open gates, and <math>\gamma</math> is the number of
                gates which exist in series in the channel, <math>V</math> is the transmembrane
                voltage, and <math>i_K</math> is the current flow through the channel.</paragraph>
            <paragraph>Three functions are available for accessing and editing the math block, these
                are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal classes="code">setMath(input)</literal> replaces the existing MathML string with the <literal classes="code">input</literal>
                        string</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">appendMath(input)</literal> adds the <literal classes="code">input</literal> string to the existing MathML
                        string</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="code">math()</literal> returns the stored MathML string</paragraph>
                </list_item>
            </bullet_list>
            <container classes="nb">
                <paragraph><strong>Note</strong> that there is only one MathML block stored per component. Even if
                    there is more than one equation, they’re all stored as one single
                    concatenated string.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Use the manipulation functions listed above to add your string(s)
                    to the component you created in 1.a.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Submit your model to the validator.  Expected errors at this stage
                    will be similar to those below, relating to not yet defined variables and
                    units:</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">Description: MathML ci element has the child text 'alpha_y' which does not
   correspond with any variable names present in component
   'HodgkinHuxleySingleIonChannel' and is not a variable defined within a bvar
   element.
Description: Math has a cn element with a cellml:units attribute
   'per_millivolt_millisecond' that is not a valid reference to units in
   component 'HodgkinHuxleySingleIonChannel' or a standard unit.</literal_block>
        </section>
        <section ids="define-the-variables-and-their-units" names="3.\ define\ the\ variables\ and\ their\ units">
            <title refid="id10">3. Define the variables and their units</title>
            <paragraph>Now that the mathematical behaviour is defined, the variables that have been
                used also need to be defined.  Each variable needs a name which is equal to the
                term inside the <literal classes="code">&lt;ci&gt;</literal> tags in the MathML, as well as units defined in
                the model.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Use the validator output or the MathML you’ve written to determine
                    the variables which you’ll need to declare.  These must be created, named, and
                    added to the component.  Need help? See <reference internal="True" refuri="../tutorial2/tutorial2_py#tutorial2-py"><inline classes="std std-ref">Tutorial 2</inline></reference>.</paragraph>
            </container>
            <container classes="nb">
                <paragraph><strong>Note</strong> Remember that the names you give the variables in this step must be
                    the same as the names used between the <literal classes="code">&lt;ci&gt;</literal> tags inside your MathML
                    string.</paragraph>
            </container>
            <paragraph>As well as a name and a parent component, each variable needs <literal classes="code">Units</literal>.
                These are specified using the <literal classes="code">setUnits</literal> function for a variable, just
                as you did in <reference internal="True" refuri="../tutorial3/tutorial3_py#tutorial3-py"><inline classes="std std-ref">Tutorial 3</inline></reference>.  The units you’ll need here are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>time, <math>t</math>, has units of <literal classes="code">millisecond</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph>voltage, <math>V</math>, has units of <literal classes="code">millivolt</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph>opening rate, <math>\alpha_y</math> has units <literal classes="code">per_millisecond</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph>closing rate, <math>\beta_y</math> has units <literal classes="code">per_millisecond</literal></paragraph>
                </list_item>
            </bullet_list>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> For each of the variables created in 3.a, use the
                    <literal classes="code">setUnits(name)</literal> function to add the units you’ll need.</paragraph>
            </container>
            <paragraph>Even though the final variable in our equations has no units, CellML2 requires
                every variable to have some defined.  For the proportion of open gates
                <math>y</math> use the units name <literal classes="code">dimensionless</literal>.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Submit your model to the validator.  Expected errors at this stage
                    will be similar to those below.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">- Description: Variable 'time' has an invalid units reference 'millisecond'
  that does not correspond with a standard unit or units in the variable's
  parent component or model. See section 11.1.1.2 in the CellML specification.

- Description: Math has a cn element with a cellml:units attribute 'millivolt'
  that is not a valid reference to units in component
  'HodgkinHuxleySingleIonChannel' or a standard unit.</literal_block>
        </section>
        <section ids="define-the-units-and-add-to-the-model" names="4.\ define\ the\ units\ and\ add\ to\ the\ model">
            <title refid="id11">4. Define the units and add to the model</title>
            <paragraph>The variables created above referenced unit names of <literal classes="code">millisecond</literal>,
                <literal classes="code">millivolt</literal>, <literal classes="code">per_millisecond</literal>, and <literal classes="code">dimensionless</literal>.  The
                <literal classes="code">dimensionless</literal> units are already present, so we don’t need to take any
                other action, but the other three need to be created and added.  This was
                covered in <reference internal="True" refuri="../tutorial3/tutorial3_py#tutorial3-py"><inline classes="std std-ref">Tutorial 3</inline></reference> in case you need a reminder.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Create the three units you need for this component, name, and define
                    them.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.b</strong> Check the units related to constants (that is, the <literal classes="code">&lt;cn&gt;</literal>
                    blocks) in the maths.  These units also need to be defined in the same way
                    and added to the model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.c</strong> Add all the new units into the model. Adding units to the model
                    allows other components (when you have them!) to use them as well.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>4.d</strong> Validate the final model configuration.  There should be no errors
                    at this stage.  If you do encounter any, you can compare the code you’ve
                    created to that provided in the
                    <literal classes="code">resources/tutorials_complete/tutorial5_complete.py</literal> file.</paragraph>
            </container>
        </section>
        <section ids="serialise-and-generate-code" names="5:\ serialise\ and\ generate\ code">
            <title refid="id12">5: Serialise and generate code</title>
            <paragraph>The final steps are to output our created model to a CellML2.0 file (which
                will be used in subsequent tutorials, so be sure to name it something
                meaningful!) as well as generating the C or Python files which we can use to
                investigate this component’s operation in isolation.  We will do the code
                generation step first to take advantage of the additional error checks present
                inside the <literal classes="code">Generator</literal>.</paragraph>
            <container classes="dothis">
                <paragraph><strong>5.a</strong> Create a <literal classes="code">Generator</literal> item, set the profile (that is, the output
                    language) to your choice of C (the default) or Python (see below), and
                    then submit the model for processing.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Change the generated language from the default C to Python if need be
profile = GeneratorProfile(GeneratorProfile.Profile.PYTHON)
generator.setProfile(profile)</literal_block>
            <container classes="dothis">
                <paragraph><strong>5.b</strong> Check the <literal classes="code">Generator</literal> for errors.  At this stage you can
                    expect errors related to non-initialised variables.  Go back and set the
                    following initial conditions:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><math>V(t=0)=0</math></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><math>y(t=0)=0</math></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><math>E_K(t=0)=-85</math></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><math>g_K(t=0)=36</math></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><math>\gamma(t=0)=4</math></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><math>\alpha_y(t=0)=1</math></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><math>\beta_y(t=0)=2</math></paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.c</strong> Retrieve the output code from the <literal classes="code">Generator</literal>, remembering
                    that for output in C you will need both the <literal classes="code">interfaceCode</literal> (the
                    header file contents) as well as the <literal classes="code">implementationCode</literal> (the source
                    file contents), whereas for Python you need only output the
                    <literal classes="code">implementationCode</literal>.  Write the file(s).</paragraph>
            </container>
            <paragraph>The second step is the
                same as what was covered at the end of <reference internal="True" refuri="../tutorial2/tutorial2_cpp#tutorial2-cpp"><inline classes="std std-ref">Tutorial 2</inline></reference> to use
                the <literal classes="code">Printer</literal>; you can refer back to the code and/or instructions there
                if you need to.</paragraph>
            <container classes="dothis">
                <paragraph><strong>5.d</strong> Create a <literal classes="code">Printer</literal> item and submit your model for serialisation.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.e</strong> Write the serialised string output from the printer to a CellML file.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.f</strong> Check that your files have been written correctly.  You should have
                    both the generated files (either <problematic ids="id2" refid="id1">*</problematic>.c/h or <problematic ids="id4" refid="id3">*</problematic>.py) as well as the <problematic ids="id6" refid="id5">*</problematic>.cellml
                    file.</paragraph>
            </container>
        </section>
        <section ids="simulate-the-behavior-of-the-gate" names="6:\ simulate\ the\ behavior\ of\ the\ gate">
            <title refid="id13">6: Simulate the behavior of the gate</title>
            <paragraph>At this stage you should have four new files created:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>the CellML file of your model.  This will be used in later tutorials as you
                        work toward building the whole Hodgkin-Huxley model.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>the generated file for the Python profile (an example for changing profiles
                        only)</paragraph>
                </list_item>
                <list_item>
                    <paragraph>the generated files for the C profile, the header and source files.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>These last three files can be used in conjuction with a simple solver to model
                the behaviour of this ion channel.  Because this tutorial is in Python we
                give instructions for the Python solver.  For the C++ solver please see
                <reference internal="True" refuri="tutorial5_cpp#tutorial5-cpp"><inline classes="std std-ref">the C++ Tutorial 5 instructions</inline></reference> or
                <reference internal="True" refuri="../solver/solver#solver"><inline classes="std std-ref">the general solver instructions</inline></reference>.</paragraph>
            <container classes="dothis">
                <paragraph><strong>6.a</strong> Navigate to the <literal classes="code">tutorials/solver</literal> directory.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">cd ../solver</literal_block>
            <container classes="dothis">
                <paragraph><strong>6.b</strong>  Run the <literal classes="code">simpleSolver.py</literal> script:.  To do this you’ll need to enter:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal classes="code">-m</literal> the path to the generated file to run, relative to the solver
                                directory</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">-dt</literal> the step size for the integration variable to take, and …</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal classes="code">-n</literal> the total number of steps to take.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">python3 simplesolver.py -m path_and_filename_to_run -n number_of_steps -dt step_size</literal_block>
            <paragraph>Running your generated model for 50 steps with a step size of 0.1ms should give
                the output shown below.</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">python3 simplesolver.py -m ../tutorial5/tutorial5_IonChannelModel_generated.py -n 50 -dt 0.1

====================================================================
SIMPLE SOLVER: ../tutorial5/tutorial5_IonChannelModel_generated
--------------------------------------------------------------------

VARIABLE OF INTEGRATION (units, stepsize)
--------------------------------------------------------------------
    t (millisecond, 0.1)
    50 steps


STATE VARIABLES (units, initial value)
--------------------------------------------------------------------
    y (dimensionless, 0.0)


VARIABLES (units, initial value)
--------------------------------------------------------------------
    E_y (millivolt, -85.0)
    V (millivolt, 0.0)
    alpha_y (per_millisecond, 1.0)
    beta_y (per_millisecond, 2.0)
    g_y (milliS_per_cm2, 36.0)
    gamma (dimensionless, 4.0)
    i_K (microA_per_cm2, 0.0)


SOLUTION written to ../tutorial5/tutorial5_IonChannelModel_generated_solution.txt
====================================================================</literal_block>
            <paragraph>Note that the solution is written to the same directory as the generated file,
                not the <literal classes="code">solver</literal> directory (as for the C++ solver).  Plotting the
                solution gives <literal classes="xref std std-numref">tutorial5_image</literal>.</paragraph>
            <figure align="center" ids="tutorial5-image" names="tutorial5_image">
                <image alt="Parameter behaviour for ion channel gate" candidates="{'*': 'tutorials/images/tutorial5_image.png'}" uri="tutorials/images/tutorial5_image.png"></image>
                <caption>Behaviour of the current and ion channel status with time.</caption>
            </figure>
        </section>
    </section>
</document>
