<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="/Users/hsor001/Projects/Webstorm/test-sphinx/docs/tutorials/tutorial6/tutorial6_cpp.rst">
    <target refid="tutorial6-cpp"></target>
    <section ids="tutorial-6-c-working-with-multiple-components tutorial6-cpp" names="tutorial\ 6\ c++:\ working\ with\ multiple\ components tutorial6_cpp">
        <title>Tutorial 6 C++: Working with multiple components</title>
        <paragraph><strong>TODO</strong> The code doesn’t match the instructions - waiting for the variable parent
            issues to be sorted out.</paragraph>
        <paragraph>The outline for this tutorial is shown on the <reference internal="True" refuri="outline6#tutorial6"><inline classes="std std-ref">Tutorial 6</inline></reference>
            page. These are the C++ instructions.  For the same tutorial in Python
            please see the <reference internal="True" refuri="tutorial6_py#tutorial6-py"><inline classes="std std-ref">Tutorial 6 in Python</inline></reference> page instead.</paragraph>
        <paragraph>Resources:</paragraph>
        <block_quote>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><download_reference filename="a26156a8cdf44a9c9b4a004bbf9d13b4/CMakeLists.txt" refdoc="tutorials/tutorial6/tutorial6_cpp" refdomain="" refexplicit="False" reftarget="CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference> The CMake file for building this tutorial</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="9daa8e1d70ede2b1338eb020da9e610b/tutorial6.cpp" refdoc="tutorials/tutorial6/tutorial6_cpp" refdomain="" refexplicit="False" reftarget="tutorial6.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial6.cpp</literal></download_reference> Either the skeleton code, or ..</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="70ba15f2ec32c7f3a19f77ac5684cb90/tutorial6_complete.cpp" refdoc="tutorials/tutorial6/tutorial6_cpp" refdomain="" refexplicit="False" reftarget="tutorial6_complete.cpp" reftype="download" refwarn="False"><literal classes="xref download">tutorial6_complete.cpp</literal></download_reference> the completed tutorial code</paragraph>
                </list_item>
                <list_item>
                    <paragraph><download_reference filename="71c8df5698e64a2755cabb11a12fa0c6/tutorial_utilities.h" refdoc="tutorials/tutorial6/tutorial6_cpp" refdomain="" refexplicit="False" reftarget="../utilities/tutorial_utilities.h" reftype="download" refwarn="False"><literal classes="xref download">../utilities/tutorial_utilities.h</literal></download_reference> and
                        <download_reference filename="750d88a87c4217ca633669952f6c8046/tutorial_utilities.cpp" refdoc="tutorials/tutorial6/tutorial6_cpp" refdomain="" refexplicit="False" reftarget="../utilities/tutorial_utilities.cpp" reftype="download" refwarn="False"><literal classes="xref download">../utilities/tutorial_utilities.cpp</literal></download_reference>  Utility functions for
                        use in the tutorials.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If you did not complete Tutorial 5 you can download the file created
                        there from: <download_reference filename="2096e345a466836d0aaa1feb84038a31/tutorial5_IonChannelModel.cellml" refdoc="tutorials/tutorial6/tutorial6_cpp" refdomain="" refexplicit="False" reftarget="../resources/tutorial5_IonChannelModel.cellml" reftype="download" refwarn="False"><literal classes="xref download">../resources/tutorial5_IonChannelModel.cellml</literal></download_reference></paragraph>
                </list_item>
            </bullet_list>
        </block_quote>
        <topic classes="contents local" ids="contents" names="contents">
            <title>Contents</title>
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="setup">0: Setup</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="create-the-model">1: Create the model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id3" refid="include-more-components-in-the-model">2: Include more components in the model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="create-a-component-for-the-n-gate">3: Create a component for the n-gate</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id5" refid="connect-the-components-to-one-another">4: Connect the components to one another</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id6" refid="define-the-driving-function">5: Define the driving function</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id7" refid="serialise-the-model-and-generate-code">6: Serialise the model and generate code</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <section ids="setup" names="0:\ setup">
            <title refid="id1">0: Setup</title>
            <paragraph>Navigate into the <literal classes="code">tutorial6</literal> folder and check that you can build the
                template against the libCellML library successfully:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">cmake -DINSTALL_PREFIX=../../install .
make -j</literal_block>
            <paragraph>Running the template:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">./tutorial6</literal_block>
            <paragraph>… should give the output of the section headings which you’ll complete here:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">-----------------------------------------------
  STEP 1: Read the ion channel component
-----------------------------------------------
-----------------------------------------------
  STEP 2: Create the environment component
-----------------------------------------------
-----------------------------------------------
  STEP 3: Define the n-gate component
-----------------------------------------------
-----------------------------------------------
  STEP 4: Define the component hierarchy
-----------------------------------------------
-----------------------------------------------
  STEP 5: Define the driving function
-----------------------------------------------
-----------------------------------------------
  STEP 6: Serialise and print the model
-----------------------------------------------</literal_block>
        </section>
        <section ids="create-the-model" names="1:\ create\ the\ model">
            <title refid="id2">1: Create the model</title>
            <paragraph>By now you should be familiar and comfortable with using the API to create
                the model instance, and normally that’s how you’d start … but not this time.
                If you completed Tutorial 5 you will have created a model representing a
                gated ion channel, serialised the model and written it to a file.  A good
                idea for programming, modelling, and work in general is the DRY principle:
                <strong>Don’t Repeat Yourself</strong>.  With this in mind we want to be able to reuse the
                work that’s already done, and in particular, that useful ion channel that was
                created in Tutorial 5.  There are four possible options:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Option 0: Write it all again.  We’re not going to do that. It’s too WET
                        (Write Every Time).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Option 1: Copy the code you wrote in Tutorial 5 to create the component, and
                        simply add it here.  This is not a great solution, because it’s not as DRY as
                        it could be, but it beats writing it all from scratch again.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Option 2: Use the skills you learned in Tutorial 2 around parsing and
                        deserialising a CellML model to read the model from the file which you
                        created during Tutorial 5.  This option is DRY-er than Option 1, but will
                        involve a tweak or two because the <literal classes="code">Parser</literal> will only load the whole
                        model, not just the bits we care about.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Option 3: Instead of parsing and loading the entirety of the model from
                        Tutorial 5, just tell libCellML to reference what it needs to.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Option 3 seems to be the DRYest, and indeed this is how we will do it later on
                when the <literal classes="code">ImportSource</literal> functionality is introduced.  For now though,
                we’ll just go with Option 2 since there’s only one component inside the
                Tutorial 5 model anyway, and this tutorial is all about parenthood and
                ownership of variables.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.a</strong> Create a <literal classes="code">Parser</literal> instance and use it to deserialise the
                    model from the file created in Tutorial 5 into a new model instance.
                    This process was described in <reference internal="True" refuri="../tutorial2/tutorial2_cpp#tutorial2-cpp"><inline classes="std std-ref">Tutorial 2</inline></reference>. You
                    may like to copy that file into the working directory for this project for
                    ease of access.  If you didn’t do Tutorial 5 you can copy this file from
                    the <literal classes="code">resources/</literal> folder instead.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.b</strong> Use the <literal classes="code">printModelToTerminal</literal> function to check that you
                    have what you expect.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>1.c</strong> Create a <literal classes="code">Validator</literal> instance and check that your model is
                    valid so far.</paragraph>
            </container>
            <paragraph>Now that we’ve loaded the model and checked that it’s working, we want to
                rename parts of it so that they make more sense going forward.  Use the
                manipulation functionality you learnt in Tutorial 3 to retrieve the following
                items from the model and rename them.  Recall that you can access the items
                contained inside a model by index as well as by name.</paragraph>
            <container classes="dothis">
                <paragraph><strong>1.d</strong> Retrieve the component from the model and rename it to
                    “PotassiumChannel”.</paragraph>
            </container>
        </section>
        <section ids="include-more-components-in-the-model" names="2:\ include\ more\ components\ in\ the\ model">
            <title refid="id3">2: Include more components in the model</title>
            <paragraph>This tutorial is intended to illustrate the use of more than one component,
                and how they’re connected to each other.  Let’s get started with creating two
                more components: one to represent the environment variables which will be
                shared throughout the whole model, and one to represent details of a
                gate.</paragraph>
            <container classes="dothis">
                <paragraph><strong>2.a</strong> Create a new component named “environment”</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.b</strong> Create two new variables with the units below, and add to the
                    component.</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>V (millivolt)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>t (millisecond)</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.c</strong> Add both new components to the model.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>2.d</strong> Check that the model is valid so far using your validator instance.</paragraph>
            </container>
        </section>
        <section ids="create-a-component-for-the-n-gate" names="3:\ create\ a\ component\ for\ the\ n-gate">
            <title refid="id4">3: Create a component for the n-gate</title>
            <paragraph>The last component that we need to create is an update from our Tutorial 5
                model such that the rate constants <math>\alpha</math> and <math>\beta</math> become
                functions of voltage.  We have another choice.  We could either:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>remove all the mathematics from our existing PotassiumChannel component
                        and adjust the equations which are already there to suit, or</paragraph>
                </list_item>
                <list_item>
                    <paragraph>create another component to handle the voltage dependence, and pass its
                        computed values to our existing component.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>In a continuation of the DRY principle, we’re going to go with the latter.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.a</strong> Create a new component named “nGate”, and add five
                    new variables:</paragraph>
            </container>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><math>V</math> (millivolt)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><math>t</math> (millisecond)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><math>n</math> (dimensionless)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><math>\alpha_n</math> (per millisecond)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><math>\beta_n</math> (per millisecond)</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>You may notice that during this process you’ve created more than one
                <literal classes="code">VariablePtr</literal> instance with the symbol <literal classes="code">V</literal> or <literal classes="code">t</literal>.  The
                CellML2 specification says that you need to have variable names which are
                unique within the scope of the component in which they’re contained.  In C++
                you can mimic this using curly brackets, <literal classes="code">{...}</literal>, around your
                <literal classes="code">VariablePtr</literal> definitions.</paragraph>
            <paragraph>Next we need to define this new dependency of the <math>\alpha</math> and
                <math>\beta</math> rate constants on the voltage.  The mathematics for this is:</paragraph>
            <math_block docname="tutorials/tutorial6/tutorial6_cpp" label="True" nowrap="False" number="True" xml:space="preserve">\alpha_n = \frac {0.01(V+10)} {\exp(0.1(V+10))-1}

\beta_n = 0.125 \exp(0.0125V)

\frac {dn} {dt} = \alpha_n(1-n) - \beta_n n</math_block>
            <container classes="dothis">
                <paragraph><strong>3.b</strong> Create the appropriate MathML to represent the equations above, and
                    add to the nGate component.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>3.c</strong> Add the nGate component into the model, and validate it.</paragraph>
            </container>
            <paragraph>During step 3.c your validation should have alerted you to a set of missing
                units in the component.  These are not attached to a variable, but to a
                constant inside the MathML, but still need to be present in the parent model.</paragraph>
            <container classes="dothis">
                <paragraph><strong>3.d</strong> Create the missing units and add to the model.  Confirm that the
                    model is now valid.</paragraph>
            </container>
        </section>
        <section ids="connect-the-components-to-one-another" names="4:\ connect\ the\ components\ to\ one\ another">
            <title refid="id5">4: Connect the components to one another</title>
            <paragraph>In order for components to be able to relate to one another, we have to define
                two things.  Firstly, the hierarchy in which they exist - this is called the
                <emphasis>encapsulation</emphasis> and determines which components are able to access others. Each
                component is only visible to its direct parents, direct children, and siblings
                (those which share a direct parent).  Secondly, we need to define the way in
                which the varaibles within the component relate to those outside it.  This is
                done by creating <emphasis>equivalent variables</emphasis>.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.a</strong> Create an encapsulation hierarchy for our three components.  In
                    this tutorial, we need an arrangement such that:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>the “environment” component stands alone as a child of the model.  We don’t
                            need to change anything there.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>the “nGate” should exist entirely inside the
                            “PotassiumChannel” gate.  This hierarchy is created by adding the
                            “nGate” component into the “PotassiumChannel” component,
                            <emphasis>instead</emphasis> of adding it to the model.  Because an item can only have one
                            parent, we can remove the gate component from the model (we added it in step
                            3.c) simply by adding it to the channel component now.  It will have its
                            parent updated, and the model’s children will be updated too.</paragraph>
                    </list_item>
                </bullet_list>
            </container>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">potassiumChannel-&gt;addComponent(nGate);</literal_block>
            <container classes="dothis">
                <paragraph><strong>4.b</strong> Print the model to the screen to check your component hierarchy.
                    It should contain the section below where a <emphasis>child component</emphasis> is listed.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">...
   Component[0] has 1 child components:
       Component[0] has name: 'nGate'
       Component[0] has 5 variables:
       Variable[0] has name: 'V'
       Variable[0] has units: 'millivolt'
       Variable[1] has name: 't'
       Variable[1] has units: 'millisecond'
       Variable[2] has name: 'alpha_n'
       Variable[2] has units: 'per_millisecond'
       Variable[3] has name: 'beta_n'
       Variable[3] has units: 'per_millisecond'
       Variable[4] has name: 'n'
       Variable[4] has units: 'dimensionless'
...</literal_block>
            <paragraph>After defining how the components are arranged, we need to define which
                variables can access each other, and how.  This is done by making variables
                in different components <emphasis>equivalent</emphasis> to one another:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Making the firstVariable and secondVariable equivalent to each other
libcellml::Variable::addEquivalence(firstVariable, secondVariable);</literal_block>
            <paragraph>In our model we have defined an “environment” component which we’ll use to
                control all of the independent variables (time, voltage) during the simulation
                process.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.c</strong> Use the addEquivalence functionality to match the time and voltage
                    variables in the “environment” component with those in the other two.  Note
                    that if you have used the curly brackets {} to denote a limited scope for your
                    variable definitions earlier, you will need to retrieve the variables from
                    their components using their names, as they don’t exist in the general scope of
                    the code:</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Retrieving the pointers to the variables via their names and adding an equivalence
libcellml::Variable::addEquivalence(environment-&gt;variable("t"), potassiumChannel-&gt;variable("t"));
libcellml::Variable::addEquivalence(environment-&gt;variable("t"), nGate-&gt;variable("t"));</literal_block>
            <container classes="dothis">
                <paragraph><strong>4.d</strong> Validate your model and print the errors to the terminal using the
                    <literal classes="code">printErrorsToTerminal</literal> function.  You should see an error
                    similar to the one below.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">**TODO** ?? put error here when the validation is working ??</literal_block>
            <paragraph>There are some restrictions on which variables can be matched like this.
                Variables can only be made equivalent if they are in neighbouring components;
                that is, a direct parent, direct child, or sibling component (one with the same
                parent).   We can add these two variables into the “PotassiumChannel” component
                as they are <emphasis>sibling</emphasis> components (their parent is the model):</paragraph>
            <literal_block force="False" language="default" linenos="False" xml:space="preserve">libcellml::Variable::addEquivalence(time_in_environment, time_in_channel);</literal_block>
            <paragraph>… but we <emphasis>cannot</emphasis> make an equivalence between the <literal classes="code">t</literal> variable in the
                <literal classes="code">environment</literal> component and the <literal classes="code">t</literal> variable in the <literal classes="code">nGate</literal>
                component, because that relationship is too distant.  Instead, we need to use
                the <literal classes="code">potassiumChannel</literal> component as a go-between: it is a sibling of the
                <literal classes="code">environment</literal> as well as a direct parent of the <literal classes="code">nGate</literal>.</paragraph>
            <container classes="dothis">
                <paragraph><strong>4.e</strong> Alter the equivalence arrangement you created in step 4.d so that
                    the neighbouring component rule is followed.  You will need to do this for
                    the variables representing time <math>t</math> and voltage <math>V</math> between all
                    three components, and the gating variable <math>n</math> between the <literal classes="code">nGate</literal>
                    and <literal classes="code">potassiumChannel</literal> components.  Validate your model again.  You
                    should see a validation message similar to that shown below.</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">**TODO Put error messages here when they're working**</literal_block>
            <paragraph>The errors above are caused by the need to specify explicitly the kind of
                equivalence relationship which is allowed for each variable.  The default
                is <literal classes="code">none</literal>, which prevents any equivalent connections, hence the error
                above.</paragraph>
            <paragraph>Here’s how to think about equivalent variable interface types.  Imagine a
                family of components such that the mother has two children.  The interface
                types between the variables in these components needs to be specified as
                follows:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Between the siblings, the <literal classes="code">public</literal> interface type.  Siblings know
                        everything about each other.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Between the children and their mother, the <literal classes="code">public</literal> interface for
                        the children, but the <literal classes="code">private</literal> interface for the mother.  Parents
                        can know everything about their children, but children do not know everything
                        about their parents.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A third option is included to enable more than one kind of relationship
                        to a variable, the <literal classes="code">public_and_private</literal> type.  This is used where
                        successive generations mean that a variable needs to be <literal classes="code">private</literal> in
                        one relationship and <literal classes="code">public</literal> in another.  An uncle (the mother’s
                        brother) and the mother have a sibling-type (ie: <literal classes="code">public</literal>) interface,
                        but the mother must keep a <literal classes="code">private</literal> interface for her children too.</paragraph>
                </list_item>
            </bullet_list>
            <container classes="dothis">
                <paragraph><strong>4.f</strong>  Use the <literal classes="code">setInterfaceType</literal> function for each of the shared
                    variables to specify their avaiable interfaces.  Re-validate your model and
                    confirm that it is now free of errors.</paragraph>
            </container>
        </section>
        <section ids="define-the-driving-function" names="5:\ define\ the\ driving\ function">
            <title refid="id6">5: Define the driving function</title>
            <paragraph>In order to give the simulation something to actually simulate, we need to add
                a driving function as an input.  This simulation replicates a voltage clamp
                experiment wherein the input voltage is given a square wave and the current
                response measured, so we need to define the voltage in the
                <literal classes="code">environment</literal> component as a function of time.  (At this stage we’ll use
                the MathML markup as in previous tutorials, but in a future tutorial we’ll
                introduce the idea of Resets items as an alternative approach.)  The MathML
                below shows how piecewise functions can be used to return the absolute value of
                a given <math>x</math> variable. The <literal classes="code">&lt;otherwise&gt;</literal> statement is there as a
                default, and can apply to more than one section of the axis.</paragraph>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;piecewise&gt;
    &lt;piece&gt;
        &lt;apply&gt;&lt;minus/&gt;&lt;ci&gt;x&lt;/ci&gt;&lt;/apply&gt;
        &lt;apply&gt;&lt;lt/&gt;&lt;ci&gt;x&lt;/ci&gt;&lt;cn&gt;0&lt;/cn&gt;&lt;/apply&gt;
    &lt;/piece&gt;
    &lt;piece&gt;
        &lt;cn&gt;0&lt;/cn&gt;
        &lt;apply&gt;&lt;eq/&gt;&lt;ci&gt;x&lt;/ci&gt;&lt;cn&gt;0&lt;/cn&gt;&lt;/apply&gt;
    &lt;/piece&gt;
    &lt;otherwise&gt;
        &lt;ci&gt;x&lt;/ci&gt;
    &lt;/otherwise&gt;
&lt;/piecewise&gt;</literal_block>
            <container classes="dothis">
                <paragraph><strong>5.a</strong> Create a MathML string representing a step change such that the
                    voltage variable is set to -85 millivolts between times of 5 and 15
                    milliseconds, and 0 otherwise.  Remember that you will need to specify both
                    the units as well as their namespace in each constant
                    <literal classes="code">&lt;cn cellml:units="yourUnitsHere"&gt;</literal>, and to specify the CellML
                    namespace itself in the maths header:</paragraph>
            </container>
            <literal_block force="False" highlight_args="{}" language="xml" linenos="False" xml:space="preserve">&lt;math xmlns="http://www.w3.org/1998/Math/MathML"
      xmlns:cellml="http://www.cellml.org/cellml/2.0#"&gt;</literal_block>
            <container classes="dothis">
                <paragraph><strong>5.b</strong> Use the <literal classes="code">setMath</literal> function to add your MathML string from
                    5.a to the <literal classes="code">environment</literal> component.</paragraph>
            </container>
            <container classes="dothis">
                <paragraph><strong>5.c</strong> Call the validator to check that your model is free of errors.</paragraph>
            </container>
        </section>
        <section ids="serialise-the-model-and-generate-code" names="6:\ serialise\ the\ model\ and\ generate\ code">
            <title refid="id7">6: Serialise the model and generate code</title>
            <container classes="dothis">
                <paragraph><strong>6.a</strong> As in <reference internal="True" refuri="../tutorial1/tutorial1_cpp#tutorial1-cpp"><inline classes="std std-ref">Tutorial 1</inline></reference>, use the <literal classes="code">Printer</literal> module
                    to serialise the model, and then write it to a file.</paragraph>
            </container>
            <figure align="center" ids="tutorial6-voltage" names="tutorial6_voltage">
                <image alt="voltage step input" candidates="{'*': 'tutorials/images/tutorial6_voltage.png'}" uri="tutorials/images/tutorial6_voltage.png"></image>
                <caption>Voltage clamp stimulus.</caption>
            </figure>
            <figure align="center" ids="tutorial6-ngate" names="tutorial6_ngate">
                <image alt="n-gate dynamics" candidates="{'*': 'tutorials/images/tutorial6_ngate.png'}" uri="tutorials/images/tutorial6_ngate.png"></image>
                <caption>n-gate dynamics in response to voltage clamp stimulus.</caption>
            </figure>
            <figure align="center" ids="tutorial6-k-conductance" names="tutorial6_k_conductance">
                <image alt="Potassium channel conductance" candidates="{'*': 'tutorials/images/tutorial6_K_conductance.png'}" uri="tutorials/images/tutorial6_K_conductance.png"></image>
                <caption>Potassium channel conductance.</caption>
            </figure>
            <figure align="center" ids="tutorial6-current" names="tutorial6_current">
                <image alt="Potassium channel current" candidates="{'*': 'tutorials/images/tutorial6_current.png'}" uri="tutorials/images/tutorial6_current.png"></image>
                <caption>Potassium channel current.</caption>
            </figure>
            <container classes="dothis">
                <paragraph><strong>6.b</strong> Go and have a cuppa, you’re done!</paragraph>
            </container>
        </section>
    </section>
</document>
